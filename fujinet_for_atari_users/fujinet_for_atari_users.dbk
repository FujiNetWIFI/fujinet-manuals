<?xml version="1.0" encoding="UTF-8"?>
<book version="5.1" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xila="http://www.w3.org/2001/XInclude/local-attributes"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:trans="http://docbook.org/ns/transclusion"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Introduction to FujiNet for <trademark
    class="registered">ATARI</trademark> Users</title>

    <titleabbrev>FujiNet Introduction</titleabbrev>

    <legalnotice>
      <para>This Book is licensed under the GNU Public License, Version 3.0.
      See: <link
      xlink:href="https://www.gnu.org/licenses/gpl-3.0-standalone.html"/> for
      details.</para>
    </legalnotice>

    <author>
      <personname><firstname>Thomas</firstname>
      <surname>Cherryhomes</surname></personname>
    </author>

    <pubdate>2024.03.07</pubdate>
  </info>

  <dedication>
    <para>This book is dedicated to the thousands of
    <productname>FujiNet</productname> users, now across multiple platforms.
    You all have given the FujiNet team the drive and determination to make
    FujiNet a comprehensive</para>

    <para>platform to connect all of our retro-computing and retro-gaming
    systems together to do new and fun things.</para>
  </dedication>

  <acknowledgements>
    <para>Many thanks to the dozens of contributors to every single aspect of
    <productname>FujiNet</productname>, not limited to the hardware, the
    software, the firmware, or the documentation. But there are people that
    need to be mentioned:</para>

    <itemizedlist>
      <listitem>
        <para><personname> <firstname>Joe</firstname>
        <surname>Honold</surname> </personname></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><personname> <firstname>Thomas</firstname>
        <surname>Cherryhomes</surname> </personname></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><personname> <firstname>Jeff</firstname>
        <surname>Piepmeier</surname> </personname></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><personname> <firstname>Steve</firstname>
        <surname>Boswell</surname> </personname></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><personname> <firstname>Oscar</firstname>
        <surname>Fowler</surname> </personname></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><personname> <firstname>Mark</firstname>
        <surname>Fisher</surname> </personname></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><personname> <firstname>Jan</firstname> <surname>Krupa</surname>
        </personname></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><personname> <firstname>Benjamin</firstname>
        <surname>Krein</surname> </personname></para>
      </listitem>

      <listitem>
        <para><personname><firstname>Andy</firstname><surname>Diller</surname></personname></para>
      </listitem>
    </itemizedlist>
  </acknowledgements>

  <preface>
    <title>PREFACE</title>

    <para>Thank you for your purchase of a #FujiNet Wi-Fi Network adapter. We
    hope that this device will provide you with hours of useful enjoyment, and
    open your ATARI® computer to the wider world of Internet
    connectivity.</para>

    <para>This manual is for new users of #FujiNet to get a quick grasp on its
    comprehensive feature set, and can be thought of as both a Getting Started
    manual, as well as a reference guide.</para>
  </preface>

  <part>
    <title>USER'S GUIDE</title>

    <chapter>
      <title>What is FujiNet?</title>

      <para>FujiNet is a Wi-Fi Network Adapter that plugs into your <trademark
      class="registered">ATARI</trademark> "Peripheral" or
      <acronym>SIO</acronym> port. It provides storage, printing,
      communications, networking, and more in a single peripheral.<figure>
          <title>A FujiNet</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/fujinet-by-itself.png"/>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Based on the <trademark class="registered">Espressif
      ESP32</trademark> micro controller, FujiNet provides the <trademark
      class="registered">ATARI</trademark> computer with a wide range of
      devices that may all be used simultaneously. These devices include a
      virtual "disk" drive, a virtual "printer", a virtual "MODEM", and a
      "Network Adapter" which provides comprehensive access to a wide variety
      of local and Internet services through the use of protocol
      adapters.</para>

      <para>Each of these virtual devices is described below.</para>

      <section>
        <title>Virtual Disk Drive "D:"</title>

        <para>FujiNet provides the virtual disk device, both so that it can
        automatically load its configuration program, and to provide the
        ability to load and use software both from the local SD card slot, or
        from one of many available <acronym>TNFS</acronym> servers that are
        not only available on the Internet, but can also be run on the local
        network, as well.</para>

        <formalpara>
          <title>What is TNFS?</title>

          <indexterm>
            <primary>TNFS</primary>
          </indexterm>

          <para><acronym>TNFS</acronym> is a simple networking protocol that
          was developed by the Spectranet project, which provides network
          connectivity to <trademark class="registered">Sinclair</trademark>
          <trademark>ZX Spectrum</trademark> computers. Because the protocol
          is open source, and it was deemed useful, the FujiNet project
          implemented it as the primary method of file sharing for the virtual
          disk drive.</para>
        </formalpara>

        <para>The FujiNet provides up to eight (8) virtual "disk" drives.
        These disk drives can accept a disk or file image in one of several
        available formats (<filename>ATR</filename>, <filename>ATX</filename>,
        or <filename>XEX</filename>), which can be provided from one of eight
        (8) host slots.</para>

        <para>By selecting one of the host slots in the
        <productname>FujiNet</productname> Configuration program
        (<productname>CONFIG</productname>), a disk image can be selected,
        which can then be mounted into one of the eight device slots.</para>

        <para>FujiNet can mount one of four different file formats into a
        device slot:</para>

        <variablelist>
          <varlistentry>
            <term><filename>ATR</filename><indexterm>
                <primary>ATR</primary>
              </indexterm></term>

            <listitem>
              <para>The most common <trademark
              class="registered">ATARI</trademark> disk image format,
              originally specified by the SIO2PC project. It can support
              unprotected disks up to 65535 sectors long, and can support disk
              images with sector sizes of 128 (single density), 256 (double
              density), and 512 bytes. FujiNet also uses an unused set of
              three bytes in this header to specify which sectors are allowed
              to be written to, when the disk is mounted read only, so that
              "High Score Enabled" functionality can be supported.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><filename>ATX</filename><indexterm>
                <primary>ATX</primary>
              </indexterm></term>

            <listitem>
              <para>A disk image format specifically designed to represent the
              unique requirements for copy protected disks on ATARI® systems,
              by specifying how each track is laid out and positioned on the
              disk. This includes the alignment of each track. In addition,
              for each sector, additional information is represented to
              specify any errors that need to be properly simulated, such as
              bad, missing, or weak sectors. This format is currently
              maintained by the a8preservation project: <link
              xlink:href="https://www.a8preservation.com/">https://www.a8preservation.com/</link></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><filename>CAS</filename><indexterm>
                <primary>CAS</primary>
              </indexterm></term>

            <listitem>
              <para>A cassette image format roughly analogous to
              <filename>ATR</filename>. It stores each tape block, along with
              the delay in milliseconds before the next one should be sent.
              <emphasis role="bold">CAS files can be mounted into device slot
              8.</emphasis></para>
            </listitem>
          </varlistentry>
        </variablelist>

        <figure>
          <title>Virtual Disks</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/virtual_disk.png" scale="25"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Virtual Printer "P:"</title>

        <para>FujiNet also provides a virtual printer device, which works
        exactly the same as a physical printer attached directly to the
        <trademark class="registered">ATARI</trademark> computer. When a
        program sends something to the "P:" device, the FujiNet will simulate
        one of more than a dozen available virtual printers. The end result is
        rendered into a document which can be read in a viewer, or sent to a
        modern printer.</para>

        <figure>
          <title>Virtual Printer</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/virtual_printer.png" scale="75"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The following printers are supported:</para>

        <variablelist>
          <varlistentry>
            <term>RAW<indexterm>
                <primary>RAW</primary>
              </indexterm></term>

            <listitem>
              <para>The printer data is sent as-is, with no conversion.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>TRIM<indexterm>
                <primary>TRIM</primary>
              </indexterm></term>

            <listitem>
              <para>Like RAW, but everything after an ATASCII end of line is
              truncated.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>ASCII<indexterm>
                <primary>ASCII</primary>
              </indexterm></term>

            <listitem>
              <para>Like RAW, but every non-ASCII character is ignored.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">ATARI</trademark>
            <trademark>820</trademark><indexterm>
                <primary>ATARI 820</primary>
              </indexterm></term>

            <listitem>
              <para>A 40 column dot matrix impact printer. Used a 5x7 font
              with ASCII characters. Printed to 3 7/8 inches (98.425mm) width
              paper. Could also print sideways (vertical). Outputs in
              <filename>PDF</filename>. Matches the 400/800 systems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">ATARI</trademark>
            <trademark>822</trademark><indexterm>
                <primary>ATARI 822</primary>
              </indexterm></term>

            <listitem>
              <para>A 40 column thermal printer. Used a 5x7 font with ASCII
              characters. Printed to 4 7/16" (112.7125mm) width thermal paper.
              Could also print dot graphics. Outputs in
              <filename>PDF</filename>. Matches the 400/800 systems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">ATARI</trademark><trademark>
            825</trademark><indexterm>
                <primary>ATARI 825</primary>
              </indexterm></term>

            <listitem>
              <para>An 80 column dot matrix impact printer. Supported normal,
              elongated, and condensed fonts in 10 and 16.7 characters per
              inch widths. Could also support reverse line feeds (which could
              be used, e.g. to make multi-column text in AtariWriter), and
              other advanced features. Outputs in <filename>PDF</filename>.
              Matches the 400/800 systems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">ATARI</trademark>
            <trademark>1020</trademark><indexterm>
                <primary>ATARI 820</primary>
              </indexterm></term>

            <listitem>
              <para>A plotter which can draw calligraphic graphics using a
              pen, and one of four colors (red, green, blue, and black).
              Unlike most of the other printers in this list, this printer
              outputs in <filename>SVG</filename>. Matches the XL
              systems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">ATARI</trademark>
            <trademark>1025</trademark><indexterm>
                <primary>ATARI 1025</primary>
              </indexterm></term>

            <listitem>
              <para>An 80 column dot matrix impact printer. Uses a 5x7 font
              with ASCII characters. Printed to either single sheets or
              fan-fold tractor fed paper anywhere from 4.5 to 8.5 inches
              (114.3 to 215.9mm) wide. Could accept tractor feed or friction
              fed paper. Could also accept an automatic document feeder
              attachment. Outputs in <filename>PDF</filename>. Matches the XL
              systems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">ATARI</trademark>
            <trademark>1027</trademark><indexterm>
                <primary>ATARI 1027</primary>
              </indexterm></term>

            <listitem>
              <para>An 80 column letter quality printer. The print font is
              very close to Prestige Elite. Outputs in
              <filename>PDF</filename>. Matches the XL systems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">ATARI</trademark>
            <trademark>1029</trademark><indexterm>
                <primary>ATARI 1029</primary>
              </indexterm></term>

            <listitem>
              <para>An 80 column dot matrix impact printer. Used a 5x7 font,
              with only ASCII characters. Released in limited quantities in
              Europe. Outputs in <filename>PDF</filename>. Matches the XL
              systems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">ATARI</trademark>
            <trademark>XMM801</trademark><indexterm>
                <primary>ATARI XMM801</primary>

                <secondary>XMM801</secondary>
              </indexterm></term>

            <listitem>
              <para>An 80 column dot matrix impact printer. Epson MX80 and
              FX80 compatible. Contains many font widths. Can handle NLQ
              (near-letter-quality) mode. Outputs in <filename>PDF</filename>.
              Matches the XE systems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">ATARI</trademark>
            <trademark>XDM121</trademark><indexterm>
                <primary>ATR</primary>

                <secondary>XDM121</secondary>
              </indexterm></term>

            <listitem>
              <para>An 80 column letter quality daisy wheel printer. Produced
              letter quality output. Outputs in <filename>PDF</filename>.
              Matches the XE systems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">EPSON</trademark>
            <trademark>MX80</trademark><indexterm>
                <primary>EPSON MX80</primary>

                <secondary>MX80</secondary>
              </indexterm></term>

            <listitem>
              <para>An 80 column dot matrix impact printer with graphics
              printing capability, as well as configurable font widths. Widely
              considered the standard for dot matrix printers in the 1980s.
              Outputs in <filename>PDF</filename>. This is the printer to use
              with <trademark>The Print Shop.</trademark></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><trademark class="registered">OKI Data</trademark>
            <trademark>OkiMate 10</trademark><indexterm>
                <primary>OkiMate 10</primary>
              </indexterm></term>

            <listitem>
              <para>A thermal wax printer capable of printing vivid color
              graphics. Outputs in <filename>PDF</filename>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>GRANTIC<indexterm>
                <primary>GRANTIC</primary>
              </indexterm></term>

            <listitem>
              <para>An implementation of <personname>Claus
              Buchholz</personname>'s "<acronym>PRANTIC</acronym>" <indexterm>
                  <primary>PRANTIC</primary>
                </indexterm>screen capture to printer device. Outputs in
              <filename>PNG</filename>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>HTML Printer<indexterm>
                <primary>HTML Printer</primary>
              </indexterm></term>

            <listitem>
              <para>Useful for printing out program listings, as it embeds the
              <acronym>ATASCII</acronym> font.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section>
        <title>Virtual MODEM "R:"</title>

        <para>FujiNet also provides a virtual MODEM device by combining
        emulation for an <trademark class="registered">ATARI</trademark>
        <trademark>850</trademark> interface, and a <trademark
        class="registered">Hayes</trademark> compatible modem with AT
        instruction set. The resulting virtual device is compatible with
        existing communications programs that use the "R:" device, and can be
        used to dial hobbyist Bulletin Board Systems (BBS) hosts over raw or
        TELNET connections.</para>

        <para>The following terminal emulator programs have been tested with
        FujiNet:</para>

        <itemizedlist>
          <listitem>
            <para><productname>ICE-T</productname></para>
          </listitem>

          <listitem>
            <para><productname>BobTerm</productname></para>
          </listitem>

          <listitem>
            <para><productname>Express!</productname></para>
          </listitem>

          <listitem>
            <para><productname>AMODEM Plus</productname></para>
          </listitem>

          <listitem>
            <para><trademark class="registered">ATARI</trademark>
            <productname>Telelink I</productname></para>
          </listitem>
        </itemizedlist>

        <para>The MODEM emulation also supports opening a listening socket
        that can accept a single incoming connection. This allows existing BBS
        programs to be used as-is to accept TELNET or raw connections from
        potential "callers."</para>

        <para>The following BBS programs have been tested with FujiNet:</para>

        <itemizedlist>
          <listitem>
            <para><productname>AMIS BBS</productname></para>
          </listitem>

          <listitem>
            <para><productname>BBS Express</productname>
            <productnumber>1.0</productnumber>,
            <productnumber>2.0</productnumber>,
            <productnumber>5.0</productnumber></para>
          </listitem>

          <listitem>
            <para><productname>FoReM-26M</productname>, <productname>FoReM XE
            Professional</productname>
            <productnumber>5.4</productnumber></para>
          </listitem>

          <listitem>
            <para><productname>Carina BBS</productname></para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Network Adapter "N:"</title>

        <para>Finally, FujiNet provides a totally new <filename>N:</filename>
        device for your <trademark class="registered">ATARI</trademark>
        computer. This device brings not only any local network; the wider
        Internet, accessible from any program or programming language that
        accepts a devicespec, such as <trademark
        class="registered">ATARI</trademark><trademark> BASIC, or
        AtariWriter</trademark></para>

        <para>This is made possible by the addition of <emphasis>protocol
        adapters</emphasis> which perform all the heavy lifting for the
        complex protocols used by the modern Internet. These adapters run on
        the FujiNet itself, and utilize its increased processing power to
        create an easy to use I/O channel for the <trademark
        class="registered">ATARI</trademark> computer.</para>

        <figure>
          <title>The HTTP Protocol Adapter</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/virtual_network.png" scale="73"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Once you have loaded a DOS disk with the "N:" handler, you can,
        for example, load a BASIC program, directly from a web server:</para>

        <sidebar>
          <example>
            <title>Loading a BASIC Program from a Web Server</title>

            <screen>READY
RUN"N:HTTP://FUJINET-TESTING.IRATA.ONLINE/BLACKJACK.BAS"</screen>
          </example>
        </sidebar>

        <para>Similarly, opening a connection to a TCP socket to host
        192.168.0.123 port 1234 is as simple as:</para>

        <sidebar>
          <example>
            <title>Opening a TCP socket in BASIC</title>

            <screen>READY
OPEN #1,12,2,"N:TCP://192.168.0.123:1234/"</screen>

            <itemizedlist>
              <listitem>
                <para>12 = READ and WRITE</para>
              </listitem>

              <listitem>
                <para>2 = Translate Line-feeds into ATASCII EOL (UNIX line
                endings)</para>
              </listitem>
            </itemizedlist>
          </example>
        </sidebar>

        <para>Once a connection is opened, writing to it is equally as
        simple:</para>

        <sidebar>
          <example>
            <title>Writing to a TCP socket in BASIC</title>

            <screen>READY
PRINT #1;"HELLO FROM THE ATARI"</screen>

            <para>The EOL here is translated into a UNIX line feed, because of
            how the connection was previously opened.</para>
          </example>
        </sidebar>

        <para>Reading from an open connection, is as simple as writing to
        it:</para>

        <sidebar>
          <example>
            <title>Reading from a TCP socket in BASIC</title>

            <screen>READY
DIM A$(99)

READY
INPUT #1,A$

READY
PRINT A$
Testing from PC.</screen>
          </example>
        </sidebar>

        <para>When done with a connection, it can be closed. FujiNet will then
        disconnect the socket.</para>

        <sidebar>
          <example>
            <title>Closing the previously opened TCP socket</title>

            <screen>READY
CLOSE #1</screen>
          </example>
        </sidebar>

        <para>We hope that the addition of the Network device, a whole new
        class of Internet connected applications can be made, easily and
        affectively, by anyone in their spare time, using the tools of their
        choice.</para>
      </section>

      <section>
        <title>CP/M Compatibility</title>

        <para>FujiNet adds a complete Z80 computer emulation that runs a copy
        of RunCPM. This provides complete <trademark
        class="registered">CP/M</trademark> 2.2 compatibility, being able to
        run thousands of additional programs, such as <trademark
        class="registered">WordStar</trademark> and <trademark
        class="registered">dBASE II</trademark>.</para>

        <para>To make this easier for most users, CP/M files are stored
        directly on the SD card, without needing to deal with floppy disk
        image formats. Any CP/M program or data file in question can be copied
        to your local SD card, placed inside the CPM/ folder, and used.<figure>
            <title>CP/M Compatibility</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="figs/virtual_cpm.png" scale="73"/>
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>The CP/M emulation uses the <productname>ATR8000</productname>
        protocol for connecting the CP/M computer to the <trademark
        class="registered">ATARI</trademark>. This means that programs such as
        DT-80 can be used to provide the requisite terminal program. In
        addition, the CP/M emulation can be accessed by any <trademark
        class="registered">ATARI</trademark> MODEM program that supports the
        "R:" device.</para>
      </section>

      <section>
        <title>S.A.M. Voice "P4:"</title>

        <para>Because the micro controller provides an 8-bit
        <acronym>DAC</acronym>, and the <trademark
        class="registered">ATARI</trademark> <acronym>SIO</acronym> connector
        provides an AUDIO IN pin, it was trivial to add an implementation of
        Don't Ask Software's Software Automatic Mouth (S.A.M.) directly on the
        FujiNet device! This has the advantage of not blanking out the display
        when you wish to use the voice synthesizer.</para>

        <para>Since the P4: device is used, it means that SAM is available to
        speak at any time, simply by writing to the device.</para>

        <example>
          <title>Making SAM Talk is Easy!</title>

          <sidebar>
            <para><screen>READY
OPEN #1,8,0,"P4:"

READY
PRINT #1;"HELLO FROM FUJINET!"</screen></para>
          </sidebar>
        </example>
      </section>

      <section>
        <title>APETIME Compatibility</title>

        <para>FujiNet includes a real-time clock that is synchronized to the
        Internet via <acronym>SNTP</acronym> (Simple Network Time Protocol),
        exposed as a device that is compatible with the
        <filename>APETIME.COM</filename> utility. Operating systems like
        SpartaDOS and SpartaDOS X can make use of this real time clock to
        provide time-stamps to files. It is also possible for any program to
        query the FujiNet to ask for the current time.</para>
      </section>
    </chapter>

    <chapter>
      <title>Unpacking and Connecting</title>

      <para>Your Fujinet comes with the following:</para>

      <itemizedlist>
        <listitem>
          <para>A FujiNet</para>
        </listitem>

        <listitem>
          <para>A USB Cable</para>
        </listitem>

        <listitem>
          <para>An SD flash card for local storage.</para>
        </listitem>

        <listitem>
          <para>This User's Guide</para>
        </listitem>

        <listitem>
          <para>A Getting Started Guide</para>
        </listitem>
      </itemizedlist>
    </chapter>

    <chapter>
      <title>Configuring your FujiNet</title>

      <para>Once the FujiNet has been connected to the ATARI computer, the
      Wi-Fi Network needs to be configured.</para>

      <para><procedure>
          <step>
            <para>Turn on your monitor.</para>
          </step>

          <step>
            <para>Turn on any peripherals you wish to also use.</para>
          </step>

          <step>
            <para>Ensure the power switch on your FujiNet is switched
            ON.</para>
          </step>

          <step>
            <para>Power on your <trademark
            class="registered">ATARI</trademark> computer.</para>
          </step>
        </procedure></para>

      <note>
        <para>If a disk drive is configured as drive 1, and is switched on,
        the FujiNet will defer to the disk drive.</para>
      </note>

      <para>While the FujiNet is responding to the Atari, the yellow activity
      light will blink.</para>

      <figure pgwide="1">
        <title>Top of FujiNet, with Yellow Activity Light</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/fujinet-diagram-top-activity.png"
                       scale="100" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>When the FujiNet is first powered on, the
      <productname>CONFIG</productname> program will boot. This will allow you
      to not only set up your wireless network information, but it will also
      allow you to boot other software from either the SD card, or from the
      network.</para>

      <para>While <productname>CONFIG</productname> loads, a splash screen is
      shown with a progress bar:</para>

      <figure pgwide="1">
        <title>FujiNet Loading Screen</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/fujinet-splash.png" scale="75"
                       scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Selecting Wi-Fi Network</title>

        <para>If FujiNet can not connect to a Wi-Fi Network, it will scan for
        any nearby networks, and present a selection screen so that the
        desired network access point, also known as an
        <acronym>SSID</acronym>, may be selected. Each entry will show the
        name of the network, and the signal strength for each network. More
        bars indicate a stronger signal. Use the arrow keys, or a joystick
        connected in port 1 to move the selection bar to the desired network.
        Press <keycap>RETURN</keycap> to confirm the selection.</para>

        <para>Once a wireless network (SSID) has been confirmed, and
        successfully connected, <acronym>CONFIG</acronym> will proceed to the
        Host List / Device Slots Screen.</para>

        <para>If the network connection is not successful, FujiNet will ask
        again for a network.</para>

        <tip>
          <para>For best performance, choose the network that is closest to
          you. This is usually indicated with a high signal strength.</para>
        </tip>

        <figure>
          <title>Selecting Wi-Fi Network</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/welcome-to-fujinet.png" scale="75"/>
            </imageobject>
          </mediaobject>
        </figure>

        <formalpara>
          <title>Entering a specific SSID</title>

          <para>If the desired network is not broadcasting its
          <acronym>SSID</acronym>, it may be explicitly entered by selecting
          <command>&lt;Enter a specific SSID&gt;</command> and entering the
          desired <acronym>SSID</acronym>, followed by pressing
          <keycap>RETURN</keycap>.</para>
        </formalpara>

        <formalpara>
          <title>Skipping Network Configuration</title>

          <para>If the desired network is not available, or only local storage
          is desired, the network configuration may be skipped by pressing
          <keycap>S</keycap>.</para>
        </formalpara>

        <formalpara>
          <title>Re-Scanning For Networks</title>

          <para>Pressing the <keycap>ESC</keycap> key, will cause FujiNet to
          re-scan for available networks.</para>
        </formalpara>

        <note>
          <para>Successful network configurations are saved, and remembered
          for future use. FujiNet stores the configurations of networks and
          passwords on both the internal flash memory, and on the SD
          card.</para>
        </note>

        <note>
          <para>Network configuration can be quickly moved from one FujiNet to
          another by physically moving the SD card from one unit, to
          another.</para>
        </note>
      </section>
    </chapter>

    <chapter>
      <title>Loading Software</title>

      <para>Once the network is successfully configured, or network
      configuration is skipped, the <command>HOST LIST / DRIVE SLOTS</command>
      screen is shown.</para>

      <figure pgwide="1">
        <title>HOST LIST / DRIVE SLOTS</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/host-list-drive-slots.png" scale="75"
                       scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>is HOST LIST Empty?</title>

        <para>If your host slots are empty. They may be re-entered using the
        <command>Edit</command> command using the following procedure:</para>

        <procedure>
          <title>Re-Populating Host Slots</title>

          <step>
            <para>Use arrow keys, or numbers
            <keycap>1</keycap>-<keycap>8</keycap> to select a host
            slot.</para>
          </step>

          <step>
            <para>Press <keycap>E</keycap> to edit the host slot.</para>
          </step>

          <step>
            <para>Enter the host slot name.</para>
          </step>

          <step>
            <para>Press <keycap>RETURN</keycap></para>
          </step>

          <step>
            <para>Repeat the above steps for as many host slots as
            desired.</para>
          </step>
        </procedure>

        <section>
          <title>Example Host Slots</title>

          <orderedlist>
            <listitem>
              <para><filename>SD</filename></para>
            </listitem>

            <listitem>
              <para><filename>FUJINET.ONLINE</filename></para>
            </listitem>

            <listitem>
              <para><filename>APPS.IRATA.ONLINE</filename></para>
            </listitem>

            <listitem>
              <para><filename>FUJINET.DILLER.ORG</filename></para>
            </listitem>

            <listitem>
              <para><filename>FUJINET.PL</filename></para>
            </listitem>

            <listitem>
              <para><filename>TNFS.ABBUC.SOCIAL</filename></para>
            </listitem>
          </orderedlist>
        </section>
      </section>

      <section>
        <title>HOST LIST</title>

        <para>The Host list contains 8 host slots, which specify the source of
        a disk image. As of current writing, this can be one of two
        types</para>

        <variablelist>
          <varlistentry>
            <term>SD</term>

            <listitem>
              <para>Naming a host slot SD indicates that this host slot will
              point to files on the local SD card.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>TNFS</term>

            <listitem>
              <para>Naming a host slot anything else indicates that this host
              slot points to a TNFS server with the given host name.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <section>
          <title>Selecting a Host Slot</title>

          <para>Host slots can be selected by one of three methods:</para>

          <variablelist>
            <varlistentry>
              <term>Arrows</term>

              <listitem>
                <para>The Up and Down arrow keys can move the selection bar by
                one entry.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Joystick</term>

              <listitem>
                <para>A joystick plugged into port 1 can move the selection
                bar by one entry.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>1-8</term>

              <listitem>
                <para>The number keys <keycap>1</keycap>-<keycap>8</keycap>
                can be used to quickly select an entry.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>

        <section>
          <title>Opening a Host Slot</title>

          <para>Pressing RETURN on a selected host slot, will attempt a
          connection to the host slot, and if successful, will show the files
          available on the given host slot, starting with the root
          directory.</para>
        </section>
      </section>

      <section>
        <title>DRIVE SLOTS</title>

        <para/>
      </section>
    </chapter>

    <chapter>
      <title>Using the Virtual Printer</title>

      <para/>
    </chapter>

    <chapter>
      <title>Connecting On-Line via the MODEM</title>

      <para/>
    </chapter>

    <chapter>
      <title>Using the Network Adapter</title>

      <para/>
    </chapter>
  </part>

  <part>
    <title>PROGRAMMER'S GUIDE</title>

    <chapter>
      <title>Atari BASIC</title>

      <para>Using the FujiNet Network Adapter under BASIC is possible by
      booting either a DOS with the NDEV (N:) handler, or by using the FujiNet
      NOS. Once loaded, an additional device <filename>N:</filename> will be
      available to open connections to network resources, and to use
      them.</para>

      <section>
        <title>Loading BASIC Programs from the Network</title>

        <para>Any BASIC program stored on the network (on a web server, for
        example), can be loaded using the <command>RUN</command>,
        <command>LOAD</command>, or <command>ENTER</command> commands.</para>

        <screen>READY
RUN"N:HTTP://FUJINET-TESTING.IRATA.ONLINE/BLACKJACK.BAS"</screen>
      </section>

      <section>
        <title>Opening a Connection</title>

        <para>BASIC's OPEN statement can be used to open a connection to a
        network endpoint. It has the following format:</para>

        <screen>READY
OPEN #iocb,aux1,aux2,"N:PROTO://HOSTNAME:PORT/PATH/TO/FILE"</screen>

        <para>Where:</para>

        <variablelist>
          <varlistentry>
            <term>iocb</term>

            <listitem>
              <para>an IO Control Block number from 1 to 7.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>aux1</term>

            <listitem>
              <para>4 = read (HTTP GET), 6 = directory (PROPFIND), 8 = write
              (or POST), 9 = append, 12 = read/write (HTTP GET), 13 =
              POST</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>aux2</term>

            <listitem>
              <para>Translation mode. 0 = none, 1 = CR&lt;-&gt;EOL (old
              MacOS), 2 = LF&lt;-&gt;EOL (UNIX), 3 = CR/LF&lt;-&gt;EOL
              (Windows PC)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PROTO</term>

            <listitem>
              <para>The Network protocol to use, examples include TCP, UDP,
              HTTP(S), FTP, TNFS, SMB</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>HOSTNAME</term>

            <listitem>
              <para>The host name or IP address to connect to.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PORT</term>

            <listitem>
              <para>Optional. Specify the numbered port for a service
              (1-65535)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PATH/TO/FILE</term>

            <listitem>
              <para>Some protocols specify file systems; so a path can be
              specified here.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para><example>
            <title>OPENing a web server document in BASIC</title>

            <screen>OPEN #1,4,0,"N:HTTPS://WWW.ICANHAZIP.COM"</screen>
          </example></para>

        <simplesect>
          <title>Common OPEN Errors</title>

          <para>The following errors can be emitted if there is a problem
          opening the connection:</para>

          <variablelist>
            <varlistentry>
              <term>ERROR- 129</term>

              <listitem>
                <para>The <acronym>IOCB</acronym> you attempted to open, is
                already in use. The <command>CLOSE</command> statement can
                close the connection.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>ERROR- 200</term>

              <listitem>
                <para>The connection you've attempted has been explicitly
                refused by the endpoint.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>ERROR- 201</term>

              <listitem>
                <para>The endpoint you attempted to open is not able to be
                routed.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>ERROR- 202</term>

              <listitem>
                <para>The socket you've attempted to use didn't finish opening
                the connection. <emphasis role="bold">This is most common for
                non-existent services.</emphasis></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </simplesect>
      </section>

      <section>
        <title>Reading from Connection</title>

        <para>Once the connection is opened, both the <command>INPUT</command>
        and <command>GET</command> statements can be used to read from a
        network endpoint. They operate exactly as expected, where INPUT will
        read one line at a time, broken up by the appropriate end of line
        character (specified by the <emphasis role="bold">aux2</emphasis> in
        the <command>OPEN</command> statement), and <command>GET</command>
        will retrieve one byte at a time from the input channel.</para>

        <note>
          <para>A connection must be opened with an aux1 of 4, 6, 12, or 13 in
          order to read from it.</para>
        </note>

        <example>
          <title>Reading One Line at a time in BASIC.</title>

          <para>Reading one line at a time can be accomplished via
          <command>INPUT</command> :</para>
        </example>

        <screen>READY
DIM A$(99)

READY
INPUT #1,A$

READY
PRINT A$
96.112.44.63
</screen>

        <example>
          <title>Reading One byte at a time in BASIC</title>

          <para>Reading one byte at a time can be accomplished via
          <command>GET</command> :</para>
        </example>

        <screen>READY
GET #1,A

READY
PRINT A,CHR$(A)
57        9</screen>

        <important>
          <para><emphasis role="bold">INPUT and GET will block, meaning that
          they will wait until something is ready to be received.</emphasis>
          You can check for bytes waiting ahead of time by using the
          <command>STATUS</command> statement, and subsequently reading
          PEEK(746) and PEEK(747) for number of bytes waiting.</para>
        </important>
      </section>

      <section>
        <title>Writing to Connection</title>

        <para>With an open connection, the PRINT and PUT statements can be
        used to write to an open network connection. They operate exactly as
        expected, where PRINT will send one line at a time to the network
        connection, and PUT will send one byte at a time to the network
        connection.</para>

        <note>
          <para>A connection must be opened with an aux1 of 8, 12, or 13 in
          order to write to it.</para>
        </note>

        <example>
          <title>Writing One Line at a time, in BASIC.</title>

          <para><command>PRINT</command> can write one line of data at a time
          to a network endpoint.<screen>READY
PRINT #1;"HELLO FROM ATARI"</screen></para>
        </example>

        <example>
          <title>Writing One Byte at a time, in BASIC.</title>

          <para><command>PUT</command> can write one line of data at a time to
          a network endpoint.<screen>READY
REM PUT A CR AND A LF
PUT #1,13:PUT #1,10</screen></para>
        </example>

        <section>
          <title>Flushing Connection Output</title>

          <para>FujiNet will automatically flush the output to a connection if
          either of the following two conditions are met:</para>

          <itemizedlist>
            <listitem>
              <para>If an ATASCII end of line character (155 decimal, $9B
              hexadecimal) is sent, or...</para>
            </listitem>

            <listitem>
              <para>If more than 127 non end of line characters are
              sent.</para>
            </listitem>
          </itemizedlist>

          <para>If you need to send data through the channel, and neither of
          these two conditions are met, the following <command>XIO</command>
          command can be used to force a flush of the buffer:</para>

          <example>
            <title>Forcing a Flush of the Output Channel, in BASIC.</title>

            <screen>XIO 15,#1,12,2,"N:"</screen>

            <note>
              <para><acronym>aux1</acronym> and <acronym>aux2</acronym> values
              should match the values you specified during
              <command>OPEN</command>.</para>
            </note>
          </example>
        </section>
      </section>

      <section>
        <title>Getting Connection Status</title>

        <para>A STATUS statement can be used to determine the current status
        of an open connection. While STATUS requires that a variable be used,
        this currently returns the last error experienced on the connection,
        while the four bytes of <acronym>DVSTAT</acronym> indicate the current
        connection status.</para>

        <table>
          <title>PEEKable Status Values</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry align="center">PEEK ADDRESS</entry>

                <entry align="center">DESCRIPTION</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>PEEK(746)</entry>

                <entry># of bytes waiting (LO)</entry>
              </row>

              <row>
                <entry>PEEK(747)</entry>

                <entry># of bytes waiting (HI)</entry>
              </row>

              <row>
                <entry>PEEK(748)</entry>

                <entry>0=Disconnected, 1=Connected</entry>
              </row>

              <row>
                <entry>PEEK(749)</entry>

                <entry>Last error returned.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <simplesect>
          <title># of Bytes Waiting</title>

          <para>The number of bytes waiting is expressed as a 16-bit number,
          with the least significant 8 bits first, followed by the most
          significant 8 bits. This means that the FujiNet will actively report
          up to 65535 bytes waiting, even though there may be more in the
          receive buffer.</para>

          <para>The following variable assignment can be used to get the total
          number of bytes waiting.</para>

          <example>
            <title>Getting # of bytes waiting</title>

            <screen>STATUS #1,A:BW=PEEK(747)*256+PEEK(746)</screen>
          </example>
        </simplesect>
      </section>

      <section>
        <title>Closing a Connection</title>

        <para>The CLOSE statement can close a connection that has been opened
        by OPEN. This has the effect of disconnecting the socket.<screen>READY
CLOSE #1</screen></para>
      </section>

      <section>
        <title>Opening a Server (Listening) Connection</title>

        <para>In addition to creating client connections, FujiNet can also
        listen for incoming connections on a given port, and hand them off to
        the <trademark class="registered">ATARI</trademark> for subsequent
        communication. This is done by opening a connection without a host
        name, but with a port number. Once opened, the FujiNet will listen for
        connections on the specified port, and the STATUS statement can be
        used to check for any incoming connections. Once an incoming
        connection is found, an XIO command may be sent to accept the
        connection and subsequently communicate with it.</para>

        <example>
          <title>Opening a Listening Connection in BASIC</title>

          <para>This example opens a TCP connection on port 6502, using IOCB
          #1, making the socket read and write with aux1 = 12, and translating
          to and from UNIX line endings with aux2 = 2.</para>

          <screen>READY
OPEN #1,12,2,"TCP://:6502"</screen>
        </example>

        <note>
          <para>As of 2024-03-13, TCP is the only protocol that currently
          supports creating a listening socket.</para>
        </note>
      </section>

      <section>
        <title>Checking for a Client Connection</title>

        <para>A STATUS statement can be used to check for an incoming
        connection. For listening sockets, the only appropriate
        <acronym>DVSTAT</acronym> byte is PEEK(748), which can be repeatedly
        checked via the following BASIC statement, which creates a loop that
        only breaks when there is a connection waiting:</para>

        <programlisting>30 STATUS #1,A:IF NOT PEEK(748) THEN 30</programlisting>
      </section>

      <section>
        <title>Accepting a Client Connection</title>

        <para>If PEEK(748) from a previous STATUS statement returns a 1, a
        connection is waiting to be accepted. Sending the following XIO
        command will accept the connection, and allow it to be used just like
        a client connection.<example>
            <title>Accepting a Client Connection, in BASIC.</title>

            <screen>XIO ASC("A"),#1,12,2,"N:"</screen>
          </example></para>

        <para>Once a connection is accepted, any subsequent STATUS statements
        will return the same information according to the "PEEKable Status
        Values" table. This status should periodically be checked to ensure
        that the connection is still connected. If the client disconnects,
        then it is the responsibility of the server program to close the
        client connection using the XIO command in the next section.</para>
      </section>

      <section>
        <title>Closing an Accepted Connection</title>

        <para>A server can choose to disconnect an accepted connection. This
        turns the channel back into a Listening Connection, so that another
        connection may be subsequently accepted.</para>

        <example>
          <title>Closing an Accepted Connection, in BASIC.</title>

          <screen>XIO ASC("c"),#1,12,2,"N:"</screen>
        </example>
      </section>

      <section>
        <title>Closing the Server (Listening) Connection</title>

        <para>When a program chooses to shut down, it is a good idea to close
        the listening socket, so that it may be subsequently used for other
        tasks. A CLOSE statement is sufficient for this. As a side-effect, any
        connected client will also be disconnected.</para>

        <example>
          <title>Closing the Listening Connection, in BASIC.</title>

          <screen>CLOSE #1</screen>
        </example>
      </section>

      <section>
        <title>Example Programs</title>

        <para>This section provides listings of example programs that use the
        N: device.</para>

        <section>
          <title>NETCAT: A Simple Terminal Emulator</title>

          <para>NETCAT is a program which acts like a simple dumb terminal
          emulator. It will read and display any information that appears on
          the network channel, while also checking for key presses and sending
          them out the same network channel. This will continue until either
          the host disconnects, or a network error occurs. In either case, the
          network channel is closed, and the program ends.</para>

          <para><example>
              <title>NETCAT Program Listing, in BASIC.</title>

              <programlisting>10 REM THE SIMPLEST DUMB TERMINAL
20 REM POSSIBLE, WITH THE N: DEVICE
100 OPEN #1,12,2,"N:TCP://BBS.FOZZTEXX.NET/"
101 OPEN #2,4,0,"K:"
102 TRAP 140
110 IF PEEK(764)=255 THEN 120
111 GET #2,K
112 PUT #1,K
113 XIO 15,#1,12,2,"N:"
120 STATUS #1,A
121 BW=PEEK(747)*256+PEEK(746)
122 IF BW=0 THEN 110
130 FOR M=1 TO BW
131 GET #1,C
132 PUT #16,C
133 NEXT M
134 GOTO 110
140 CLOSE #1
150 PRINT "DISCONNECTED"
160 END</programlisting>
            </example>Lines 10 and 20 are simple remarks indicating the
          program and its function.</para>

          <para>Line 100 opens a TCP connection to BBS.FOZZTEXX.COM. This can
          be changed to point to something else, even a different
          protocol.</para>

          <para>Line 101 opens the Keyboard device for subsequent
          input.</para>

          <para>Line 102 sets a TRAP for line 140, which will close the
          connection, e.g. if the host disconnects, or there is an
          error.</para>

          <para>Line 110 Checks for a pressed key, and jumps to line 120 if no
          key is pressed.</para>

          <para>Line 111 If a key is pressed, read it into variable K.</para>

          <para>Line 112 Put the resulting key press into the network
          channel.</para>

          <para>Line 113 Flush the resulting character out to the network
          channel.</para>

          <para>Line 120 Get the status of the network channel.</para>

          <para>Line 121 Set <emphasis role="bold">BW</emphasis> to the number
          of bytes waiting by combining the bytes in PEEK(746) and
          PEEK(747).</para>

          <para>Line 122 If there are no bytes waiting, jump back to line
          110.</para>

          <para>Line 130 Start a loop, based on the number of bytes waiting,
          for each byte:</para>

          <para>Line 131 Retrieve the byte from the network channel.</para>

          <para>Line 132 Put the byte to the screen (channel #16 becomes
          channel #0, which is the E: device)</para>

          <para>Line 133 Close the loop</para>

          <para>Line 134 Return to line 110, so we can check for a key press,
          again, and repeat the whole process.</para>

          <para>Line 140 Any error will trap to this line, which closes the
          network channel.</para>

          <para>Line 150 Print "DISCONNECTED" to the screen.</para>

          <para>Line 160 End the program. This closes the Keyboard device,
          too.</para>
        </section>

        <section>
          <title>MASTODON: Show the newest Mastodon post</title>

          <para>MASTODON is an example program that demonstrates not only the
          <acronym>HTTPS</acronym> protocol adapter, but also the built-in
          <acronym>JSON</acronym> parser. A connection to
          <emphasis>oldbytes.space</emphasis>, a Mastodon server dedicated to
          retro computing, is opened. Once opened, the newest public post is
          retrieved. The resulting post is then parsed and queried for the
          poster's name, the date of the post, and the post's content. All
          three of these pieces of information are displayed as they're being
          queried. Once done, the network connection closes, and the program
          waits approximately 3 minutes, before looping back to the start of
          the program. The program repeats until the <keycap>BREAK</keycap>
          key is pressed.</para>

          <para>Another unique aspect of this program is the simplification of
          not needing to use <command>STATUS</command> to get the # of bytes
          waiting, relying instead on an end-of-file (<acronym>EOF</acronym>)
          error to stop reading data during the loop at line 90.</para>

          <example>
            <title>MASTODON Program Listing, in BASIC.</title>

            <programlisting>0 DIM A$(256)
1 TRAP 91
2 POKE 756,204
10 OPEN #1,12,0,"N:HTTPS://OLDBYTES.SPACE/api/v1/timelines/public?limit=1"
20 XIO 252,#1,12,1,"N:"
30 XIO ASC("P"),#1,12,0,"N:"
40 XIO ASC("Q"),#1,12,3,"N:/0/account/display_name"
50 INPUT #1,A$:? A$
60 XIO ASC("Q"),#1,12,3,"N:/0/created_at"
70 INPUT #1,A$:? A$
80 XIO ASC("Q"),#1,12,3,"N:/0/content"
90 GET #1,A:? CHR$(A);:GOTO 90
91 CLOSE #1:? :?
100 POKE 18,0:POKE 19,0:POKE 20,0
110 IF PEEK(19)&lt;30 THEN 110
120 GOTO 1</programlisting>
          </example>

          <para>Line 0 dimensions a 256 byte string variable A$.</para>

          <para>Line 1 sets 91 as an error trap.</para>

          <para>Line 2 changes the character set base to the International
          Character set. This line may be omitted on <trademark
          class="registered">ATARI</trademark> <trademark>400/800</trademark>
          systems, which do not have this character set.</para>

          <para>Line 10 opens a connection to the
          <emphasis>oldbytes.space</emphasis> Mastodon server using the
          <acronym>HTTPS</acronym> protocol. The path points to an API call
          that fetches posts from the public time line. The "?" Indicates a
          GET query parameter, and in this case limit=1 ensures that the
          server only sends a single post.</para>

          <para>Line 20 uses <command>XIO</command> to send a SET CHANNEL MODE
          command. This changes the channel to allow the
          '<command>P</command>'arse and '<command>Q</command>'uery commands
          that will be used on the proceeding lines.</para>

          <para>Line 30 uses <command>XIO</command> to send a PARSE command.
          This reads the network channel until there is no more data. The
          channel is subsequently passed through the JSON parser, with the
          results of the parse sitting in FujiNet memory, to be queried using
          the '<command>Q</command>'uery command.</para>

          <para>Line 40 uses <command>XIO</command> to send a
          '<command>Q</command>'uery command. This particular
          <acronym>JSON</acronym> Query asks for the display name of a given
          poster. However, it is inside an array, so we have to ask for the
          first element of the array as part of the query, hence the
          "/0/"</para>

          <para>Line 50 calls INPUT to read the queried result into variable
          A$, and subsequently display it on screen with the
          '<command>?</command>' statement.</para>

          <para>Line 60 uses <command>XIO</command> to send a
          '<command>Q</command>'uery command which asks for the created_at key
          for the very first returned post.</para>

          <para>Line 70 calls <command>INPUT</command> to read the queried
          result into variable A$, and subsequently display it.</para>

          <para>Line 80 uses <command>XIO</command> to send a final
          '<command>Q</command>'uery command, which asks for the content for
          the very first returned post.</para>

          <para>Line 90 Sets up an infinite loop which <command>GET</command>s
          and displays one byte at a time, because <command>INPUT</command>
          can only fetch single lines up to 127 bytes long. The end of the
          content will generate an end of file (<acronym>EOF</acronym>) error,
          so the <command>TRAP</command> will cause the loop to exit.</para>

          <para>Line 91 is the destination of the <command>TRAP</command>
          statement, which closes the network connection, while printing two
          blank lines.</para>

          <para>Line 100 resets the real time clock.</para>

          <para>Line 110 sets up a loop which exits when
          <function>PEEK</function>(19) is equal to 30, which is approximately
          3 minutes.</para>

          <para>Line 120 jumps back to the TRAP statement on line 1, which
          re-starts the program, while taking care not to re-dimension the A$
          variable.</para>
        </section>

        <section>
          <title>WEBSRVR: A Simple Web Server</title>

          <para>This example uses the TCP protocol to open a simple web server
          on port 8080. It does the absolute bare minimum of answering a
          connection, accepting a command, and then sending back a response to
          a browser, and should only be used as a minimal starting point, as a
          real HTTP server requires a lot more work, and is beyond the scope
          of this manual.</para>

          <para>Once the program is waiting for a connection, you can connect
          with a browser to the IP address or host name of your FujiNet, and
          you should see the message "Hello from my Atari!" in a large bold
          font.</para>

          <example>
            <title>WEBSRVR Program Listing, in BASIC.</title>

            <programlisting>100 REM SIMPLE WEB SERVER
101 DIM A$(127)
110 OPEN #1,12,3,"N:TCP://:8080"
120 PRINT "WAITING..."
121 TRAP 250
130 STATUS #1,A
140 IF  NOT PEEK(748) THEN 130
150 PRINT "ACCEPTING..."
160 XIO ASC("A"),#1,12,3,"N:"
170 PRINT "READING HTTP COMMAND..."
171 STATUS #1,A
172 BW=PEEK(746)+256*PEEK(747)
173 IF NOT BW THEN 198
180 INPUT #1,A$
190 GOTO 171
199 PRINT "SENDING DOCUMENT..."
200 PRINT #1;"HTTP/1.1 200 OK"
210 PRINT #1;"Content-Type: text/html"
230 PRINT #1;""
240 PRINT #1;"&lt;html&gt;"
241 PRINT #1;"&lt;head&gt;"
242 PRINT #1;"&lt;title&gt;Atari Web Server&lt;/title&gt;"
243 PRINT #1;"&lt;/head&gt;"
244 PRINT #1;"&lt;body&gt;"
245 PRINT #1;" &lt;h1&gt;Hello from my Atari!&lt;/h1&gt;"
246 PRINT #1;"&lt;/body&gt;"
247 PRINT #1;"&lt;/html&gt;"
250 XIO ASC("c"),#1,12,3,"N:"
260 GOTO 120</programlisting>
          </example>

          <para>Line 100 is a simple remark indicating the program's
          function.</para>

          <para>Line 101 defines a single string variable A$ which is 127
          bytes long.</para>

          <para>Line 110 opens a TCP listening port, at port 8080. Aux1 is set
          to 12, which means read/write, and aux2 is set to 3, which means to
          convert ATASCII EOL to and from an ASCII CR/LF pair.</para>

          <para>Line 120 prints "WAITING..."</para>

          <para>Line 121 sets a TRAP to line 250.</para>

          <para>Line 130 Asks for the network channel status</para>

          <para>Line 140 checks if the CONNECTED byte is set to 1, if so, we
          fall through, otherwise we loop back.</para>

          <para>Line 150 prints "ACCEPTING..."</para>

          <para>Line 160 uses XIO command "A" on the N: device, to accept the
          connection, taking care to use the same aux1 and aux2 parameters
          specified in OPEN.</para>

          <para>Line 170 prints "READING HTTP COMMAND..."</para>

          <para>Line 171 asks for network channel status</para>

          <para>Line 172 sets BW to # of bytes waiting</para>

          <para>Line 173 breaks out of the loop if no bytes waiting, to send
          the document.</para>

          <para>Line 180 Reads the next line from the PC, we ignore it.</para>

          <para>Line 190 loops back to 171, unless there isn't any data
          waiting.</para>

          <para>Line 199 prints "SENDING DOCUMENT"</para>

          <para>Lines 200-247 sends the HTTP response, and the
          document.</para>

          <para>Line 250 closes the client connection</para>

          <para>Line 260 returns to line 120</para>
        </section>
      </section>
    </chapter>

    <chapter>
      <title>FastBASIC</title>

      <para>DMSC's FastBASIC is a very fast BASIC interpreter and compiler,
      able to not only leverage the unique hardware capabilities of the ATARI
      computers, but comes with FujiNet commands built into the language.
      These commands are implemented using the SIO interface, so the N: device
      handler is not required.</para>

      <para>The FastBASIC package comes with an interpreter and compiler that
      run both on the native ATARI computer, but also cross-compilers which
      can run on any Windows or POSIX (e.g. MacOS and Linux) compliant system,
      making development fast and convenient.</para>

      <para>The latest copy of FastBasic may be downloaded from GitHub: <link
      xlink:href="https://github.com/dmsc/fastbasic">https://github.com/dmsc/fastbasic</link></para>

      <section>
        <title>Opening a Connection</title>

        <para>The NOPEN statement is used to open a network connection.</para>

        <screen>NOPEN unit, aux1, aux2, url$</screen>

        <variablelist>
          <varlistentry>
            <term>unit</term>

            <listitem>
              <para>Selects the N: device to open, which can be from 1 to
              8.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>aux1</term>

            <listitem>
              <para>Sets the mode of the channel, 4 = read only (GET), 6 =
              directory (PROPFIND), 8 = write (PUT), 9 = append, 12 =
              read/write (GET), 13 = POST</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>aux2</term>

            <listitem>
              <para>Sets the translation mode, 0 = no translation, 1 =
              CR&lt;-&gt;EOL, 2 = LF&lt;-&gt;EOL, 3 = CR/LF&lt;-&gt;EOL</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>url$</term>

            <listitem>
              <para>A string specifying the URL of the form:
              N:PROTOCOL://HOSTNAME:PORT/PATH...</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <example>
          <title>Opening a Network Connection, in FastBASIC.</title>

          <screen>NOPEN 1,12,2,"N:TELNET://BBS.FOZZTEXX.COM/"</screen>
        </example>
      </section>

      <section>
        <title>Reading from Connection</title>

        <para>The NGET statement can be used to read bytes from a connection,
        of a specified number of bytes, into a byte array.</para>

        <screen>NGET unit, adr, len</screen>

        <variablelist>
          <varlistentry>
            <term>unit</term>

            <listitem>
              <para>Selects the N: device to input, which can be from 1 to
              8.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>adr</term>

            <listitem>
              <para>The address of the destination buffer in memory. Most
              commonly pointing to a byte array by way of the &amp;
              operator.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>len</term>

            <listitem>
              <para>The exact number of bytes to read (1-65535)</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <tip>
          <para><varname>len</varname> must be less than or equal to the
          number of bytes available in the receive buffer. Use
          <command>NSTATUS</command> followed by
          <function>DPEEK($02EA)</function> to get the number of bytes
          available.</para>
        </tip>

        <example>
          <title>Reading from a Connection in FastBASIC</title>

          <programlisting>DIM BUF(256) BYTE

<command>NSTATUS</command> 1
<command>BW</command> = <function>DPEEK</function>($02EA)

' BECAUSE INTS ARE SIGNED, MUST
' TAKE VALUES &gt; 32767 INTO 
' ACCOUNT

IF <varname>BW</varname> &gt; 256 OR <varname>BW</varname> &lt; 000
  <varname>LN</varname> = 256
ELSE
  <varname>LN</varname> = BW

<command>NGET</command> 1,&amp;BUF,LN</programlisting>
        </example>
      </section>

      <section>
        <title>Writing to Connection</title>

        <para>The <command>NPUT</command> statement can be used to write a
        length of bytes from a specific buffer to a network channel.</para>

        <screen><command>NPUT</command> unit, adr, len</screen>

        <variablelist>
          <varlistentry>
            <term>unit</term>

            <listitem>
              <para>Selects the N: device to output, which can be from 1 to
              8</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>adr</term>

            <listitem>
              <para>The address of the source buffer in memory. Most commonly
              pointing to a byte array by way of the &amp; operator.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>len</term>

            <listitem>
              <para>The exact number of bytes to write (1-65535)</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <example>
          <title>Writing to a connection, in FastBASIC</title>

          <programlisting>' GET KEY FROM KEYBOARD
' THEN SEND IT TO NETWORK CONNECTION

<command>GET</command> K
<command>NPUT</command> 1,&amp;K,1</programlisting>
        </example>
      </section>

      <section>
        <title>Getting Connection Status</title>

        <para>The <command>NSTATUS</command> statement can be used to get the
        current status of a specific unit. The result is placed into the
        <varname>DVSTAT</varname>.</para>

        <screen><command>NSTATUS</command> unit</screen>

        <variablelist>
          <varlistentry>
            <term>unit</term>

            <listitem>
              <para>Selects the N: device to acquire status, which can be from
              1 to 8</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The following table shows the contents of
        <varname>DVSTAT</varname> and what function should be used to read
        it.</para>

        <table>
          <title>Contents of DVSTAT, in FastBASIC</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry align="center">Offset</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><function>DPEEK($02EA)</function></entry>

                <entry>Returns the number of bytes waiting in the receive
                buffer (1-65535)</entry>
              </row>

              <row>
                <entry><function>PEEK($02EC)</function></entry>

                <entry>1 = Channel connected, 0 = Disconnected</entry>
              </row>

              <row>
                <entry><function>PEEK($02ED)</function></entry>

                <entry>Returns the error code of the last operation.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <example>
          <title>Obtaining Status, in FastBASIC</title>

          <programlisting>' Get current status
NSTATUS 1

' Put into useful variables
BW=DPEEK($02EA)
CONNECTED=DPEEK($02EC)
ERR=PEEK($02ED)</programlisting>
        </example>
      </section>

      <section>
        <title>Closing a Connection</title>

        <para>The <command>NCLOSE</command> statement will close a connection
        attached to a specific unit. If the given unit doesn't have an open
        connection, the NCLOSE statement will simply return to the main
        program.</para>

        <screen><command>NCLOSE</command> unit</screen>

        <variablelist>
          <varlistentry>
            <term>unit</term>

            <listitem>
              <para>Selects the N: device to close, which can be from 1 to
              8.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <example>
          <title>Closing a connection, in FastBASIC</title>

          <programlisting>' Close connection on N: unit 1
<command>NCLOSE</command> 1</programlisting>
        </example>

        <caution>
          <para>When a unit is opened as a listening socket,
          <command>NCLOSE</command> will close the listening socket. A delay
          of 2 minutes is imposed for any closed listening sockets, before
          they are available again for use. If you intend to re-use the
          listening socket to accept another connection, please refer to
          "<emphasis role="bold">Closing the Server (Listening)
          Connection</emphasis>"</para>
        </caution>
      </section>

      <section>
        <title>Opening a Server (Listening) Connection</title>

        <para>NOPEN can be used to create a listening socket on a specified
        port. This is used to accept connections from another computer.</para>

        <example>
          <title>Opening a Server (Listening) Connection, in FastBASIC</title>

          <programlisting>' Open a TCP listening (server) socket on port 6502
' 0 = No Translation (e.g. Atari-to-Atari)

NOPEN 1,12,0,"N:TCP://:6502/"</programlisting>
        </example>
      </section>

      <section>
        <title>Checking for a Client Connection</title>

        <para>NSTATUS can be used to check the listening connection for a
        connection. PEEK($02EC) will return a 0 if there is no connection
        waiting, or a 1 if there is a connection waiting.</para>

        <example>
          <title>Checking for a Server Connection, in FastBASIC</title>

          <programlisting>' NSTATUS must be run each connected check.
NSTATUS 1
CONNECTED=PEEK($02EC)
IF CONNECTED THEN
   ' ...</programlisting>
        </example>
      </section>

      <section>
        <title>Accepting a Client Connection</title>

        <para>Connections can be accepted by sending an 'A' command to the
        appropriate N: unit. The SIO command can be used to do this, and for
        convenience, can be wrapped into the following PROCedure:</para>

        <programlisting>PROC naccept unit, mode, trans
 SIO $71, unit, $41, $00, 0, $1f, 0, mode, trans
ENDPROC</programlisting>

        <variablelist>
          <varlistentry>
            <term>unit</term>

            <listitem>
              <para>Accept connection for unit #1-8</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>mode</term>

            <listitem>
              <para>The channel mode to set, usually should match what was
              passed to NOPEN</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>trans</term>

            <listitem>
              <para>The translation mode to set, usually should match what was
              passed to NOPEN</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <example>
          <title>Accepting a Client Connection in FastBASIC</title>

          <programlisting>naccept 1</programlisting>
        </example>
      </section>

      <section>
        <title>Closing an Accepted Connection</title>

        <para>The correct way to disconnect an accepted client connection is
        to use the following PROCedure, which sends a 'c' command to the
        appropriate network unit:</para>

        <programlisting>PROC ncloseclient unit
 SIO $71, unit, $63, $00, 0, $1f, 0, 0, 0
ENDPROC</programlisting>

        <variablelist>
          <varlistentry>
            <term>unit</term>

            <listitem>
              <para>Close any client connection for unit #1-8</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section>
        <title>Closing the Server (Listening) Connection</title>

        <para>If a program is done with a listening socket, it should be
        closed with an NCLOSE statement. The example closes the server
        (listening) connection on unit 1:</para>

        <example>
          <title>Closing the Server (Listening) Connection, in
          FastBASIC</title>

          <programlisting>NCLOSE 1</programlisting>
        </example>
      </section>

      <section>
        <title>Example Programs</title>

        <note>
          <para>The programs listed here, can be found in the FastBASIC
          samples/ directory.</para>
        </note>

        <section>
          <title>NETCAT: A Simple Terminal Emulator</title>

          <para>NETCAT is a program which acts like a simple dumb terminal
          emulator. It will read and display any information that appears on
          the network channel, while also checking for key presses and sending
          them out the same network channel. This will continue until either
          the host disconnects, or a network error occurs. In either case, the
          network channel is closed, and the program ends.</para>

          <programlistingco>
            <areaspec>
              <area coords="2" xml:id="ex.fb.nc.1"/>
            </areaspec>

            <programlisting linenumbering="numbered">' -- #FUJINET NETCAT Example --

' Default unit # for connection
CONN=2
MODE=12
TRANS=0

' RX Buffer
DIM BUF(8192) BYTE

' Procedures '''''''''''''''''''''''''
PROC BANNER
 PRINT "** NETCAT IN FASTBASIC **"
 PRINT
ENDPROC

PROC GETCONN
 URL$="N:"
 INPUT "URL: ", C$
 URL$=+C$
 INPUT "TRANS (0=none, 1=CR, 2=LF, 3=CR/LF): ", TRANS
ENDPROC

PROC INTCLR
 POKE $D302, PEEK($D302) &amp; 127
ENDPROC

PROC CONNECT
 PRINT "Connecting to:"
 PRINT URL$
 NOPEN CONN,MODE,TRANS,URL$
 NSTATUS CONN
ENDPROC

PROC IN
 ' Clear interrupt and get status
 @INTCLR
 NSTATUS CONN

 ' Check if we need to read data
 BW = DPEEK($02EA)
 WHILE BW
  ' Needs to handle the case where
  ' BW &gt; 32767, giving negative.
  IF BW &gt; 8192 OR BW &lt; 000
   LN = 8192
  ELSE
   LN = BW
  ENDIF

  NGET CONN,&amp;BUF, LN
  BPUT #0, &amp;BUF, LN
  BW = BW - LN
 WEND
ENDPROC

PROC OUT
 GET K
 NPUT CONN, &amp;K, 1
ENDPROC

PROC NC
 DO
  IF PEEK($D302) &amp; 128
   @IN
  ENDIF

  IF PEEK($02EC) = 0
   PRINT "Disconnected."
   NCLOSE CONN
   EXIT
  ENDIF

  IF KEY() THEN @OUT
 LOOP
ENDPROC

''''''''''''''''''''''''
' Main Program

POKE 65,0 ' quiet SIO

@BANNER
@GETCONN
@CONNECT

IF SErr() &lt;&gt; 1
  NSTATUS CONN
  PRINT "Could not Make Connection"
  PRINT "ERROR- "; PEEK($02ED)
  NCLOSE CONN
ELSE
  PRINT "Connected!"
  @NC
ENDIF

POKE 65,3 ' noisy SIO
</programlisting>

            <calloutlist>
              <callout arearefs="ex.fb.nc.1">
                <para>Variable definitions.</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </section>

        <section>
          <title>MASTODON: Show the newest Mastodon post</title>

          <programlisting linenumbering="numbered">' A Mastodon Client in FastBASIC

' N: Unit to use
unit=8

' URL to Mastodon Server
url$="N:HTTPS://oldbytes.space/api/v1/timelines/public?limit=1"$9B

' QUERY string
query$=""

' QUERY result
DIM result(1024) BYTE

' JSON channel mode
JSON_MODE=1

' PROCEDURES '''''''''''''''''''''''''
PROC nprinterror
 NSTATUS unit
 PRINT "ERROR- "; PEEK($02ED)
ENDPROC

PROC nsetchannelmode mode
 SIO $71, unit, $FC, $00, 0, $1F, 0, 12, JSON_MODE
ENDPROC

PROC nparsejson
 SIO $71, unit, $50, $00, 0, $1f, 0, 12, 0
ENDPROC

PROC njsonquery
 SIO $71, unit, $51, $80, &amp;query$+1, $1f, 256, 12, 0
ENDPROC

PROC showresult
 @njsonquery
 NSTATUS unit

 IF PEEK($02ED) &gt; 
  PRINT "Could not fetch query:"
  PRINT query$
  EXIT
 ENDIF

 BW=DPEEK($02EA)
 NGET unit, &amp;result, BW
 BPUT #0, &amp;result, BW
ENDPROC

PROC mastodon
 ' Open connection
 NOPEN unit, 12, 0, url$

 ' If not successful, then exit.
 IF SERR()&lt;&gt;1
  PRINT "Could not open connection."
  @nprinterror
  EXIT
 ENDIF

 ' Change channel mode to JSON
 @nsetchannelmode JSON_MODE

 ' Ask FujiNet to parse JSON
 @nparsejson

 ' If not successful, then exit.
 IF SErr()&lt;&gt;1
  PRINT "Could not parse JSON."
  @nprinterror
  EXIT
 ENDIF

 ' Show latest post
 query$="N:/0/account/display_name"$9B
 @showresult
 query$="N:/0/created_at"$9B
 @showresult
 query$="N:/0/content"$9B
 @showresult

 NCLOSE unit

 PRINT
 PRINT " ---- "
 PRINT

ENDPROC

' MAIN PROGRAM '''''''''''''''''''''''
DO
 @mastodon
 PAUSE 1800
LOOP
</programlisting>
        </section>
      </section>
    </chapter>

    <chapter>
      <title>ACTION!</title>

      <para>ACTION! programs can access the FujiNet directly, via SIO,
      allowing for FujiNet programs to be used even when there is no N:
      handler loaded.</para>

      <para>To make usage of FujiNet easier, a library called NIO.ACT is
      provided. It provides functions for opening, closing, reading, writing,
      and a few special features (such as <acronym>JSON</acronym> parsing and
      querying), and can be easily patterned to send any FujiNet command over
      SIO. The following sections show how to use the individual functions
      found in NIO.ACT.</para>

      <section>
        <title>Performing an SIO Operation</title>

        <para>ACTION! can easily communicate directly with the FujiNet via
        SIO. This is accomplished by calling the operating system routine
        <function>SIOV</function> which has a known vector address of $E459.
        This routine reads its parameters from a fixed location in memory,
        starting at address $0300 called the Device Control Block (DCB). The
        procedure for using the FujiNet via <function>SIOV</function> is as
        follows:<procedure>
            <step>
              <para>Set <varname>DDEVIC</varname> to $71.</para>
            </step>

            <step>
              <para>Set <varname>DUNIT</varname> to the N: device you wish to
              use. <function>ngetunit()</function> can help set this via a
              URL.</para>
            </step>

            <step>
              <para>Set <varname>DCOMND</varname> to the command you wish to
              send.</para>
            </step>

            <step>
              <para>Set <varname>DSTATS</varname> to indicate the direction of
              payload during transfer. $00 indicates there is no payload, $40
              indicates to send from the FujiNet to the <trademark
              class="registered">ATARI</trademark>, and $80 indicates that the
              payload goes from <trademark
              class="registered">ATARI</trademark> to the FujiNet.</para>
            </step>

            <step>
              <para>If <varname>DSTATS</varname> is $40 or $80, set
              <varname>DBUF</varname> to point to the correct buffer,
              otherwise simply set zero.</para>
            </step>

            <step>
              <para>Set <varname>DTIMLO</varname> to a value larger than 0, to
              indicate # of seconds to wait for operation to complete.</para>
            </step>

            <step>
              <para>If <varname>DSTATS</varname> is $40 or $80, set
              <varname>DBYT</varname> to the number of bytes to transfer from
              the buffer, otherwise simply set zero.</para>
            </step>

            <step>
              <para>Set <varname>DAUX1</varname> to an appropriate
              value.</para>
            </step>

            <step>
              <para>Set <varname>DAUX2</varname> to an appropriate value,
              or...</para>
            </step>

            <step>
              <para>You can also set as a 16-bit value, if you define
              <varname>DAUX</varname> as a <type>CARD</type>.</para>
            </step>

            <step>
              <para>Once everything is set, call
              <function>SIOV()</function></para>
            </step>

            <step>
              <para>Check <varname>DSTATS</varname> for error code.</para>
            </step>

            <step>
              <para>If <varname>DSTATS</varname>=144, check
              <varname>DVSTAT+3</varname> (aka ERR) for error code.</para>
            </step>
          </procedure></para>

        <para>The following code snippet defines the locations of the Device
        Control Block (<acronym>DCB</acronym>) and the function to call
        <function>SIOV</function>:</para>

        <programlisting>;
; DEVICE CONTROL BLOCK (DCB)
;
BYTE DDEVIC = $0300 ; Device #
BYTE DUNIT  = $0301 ; Unit #
BYTE DCOMND = $0302 ; Command
BYTE DSTATS = $0303 ; &lt;-&gt; and error
CARD DBUF   = $0304 ; buffer
BYTE DTIMLO = $0306 ; timeout secs
BYTE DUNUSE = $0307 ; reserved
CARD DBYT   = $0308 ; pyld byte len
CARD DAUX   = $030A ; daux1/daux2
BYTE DAUX1  = $030A ; daux1
BYTE DAUX2  = $030B ; daux2

;
; PROC to call SIO Vector (SIOV)
;
PROC siov=$E459()</programlisting>
      </section>

      <section>
        <title>Setting DUNIT via a URL</title>

        <para>The function <function>ngetunit()</function> will parse the URL
        pointed to by <varname>ds</varname> to get the requested unit number.
        It will parse N: as unit 0:</para>

        <programlisting>;
; Get the unit number from devicespec
;
BYTE FUNC ngetunit(BYTE ARRAY ds)
    BYTE unit=1
                   
    IF ds(2)=': THEN
        unit=1
    ELSEIF ds(3)=': THEN
        unit=ds(2)-$30
    ELSE
        unit=1
    FI

RETURN (unit)</programlisting>
      </section>

      <section>
        <title>Getting the error code</title>

        <para>The procedure <function>geterror()</function> can be used to
        derive the error code of the completed operation. <programlisting>BYTE EXTERR = $02ED
BYTE DSTATS = $0303

;
; Return error of last NIO operation.
; If SIO error = 144, then a status
; is done, and the extended err is 
; returned.
;
; @param devicespec N: devicespec
; @return error 1=successful
;
BYTE FUNC geterror(BYTE ARRAY ds)
  BYTE errno

  IF DSTATS=144 THEN
    nstatus(ds)
    errno=EXTERR
  ELSE
    errno=DSTATS
  FI

RETURN (errno)</programlisting></para>
      </section>

      <section>
        <title>Opening a Connection</title>

        <para>The following function <function>nopen()</function> can be used
        to open a network connection with a given protocol:</para>

        <programlisting>;
; Open the N: device pointed to by
; devicespec.
; 
; @param devicespec N: devicespec
; @param trans - translation mode
;   0=NONE, 1=CR, 2=LF, 3=CR/LF
; @return error, 1=successful.
;
BYTE FUNC nopen(BYTE ARRAY ds, BYTE t)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'O    ; OPEN
  DSTATS = $80   ; Write to fujinet
  DBUF   = ds    ; send devicespec
  DTIMLO = $1F   ; 32 second timeout
  DBYT   = 256   ; 256 byte payload
  DAUX1  = 12    ; R/W
  DAUX2  = t     ; translation
  siov();  

RETURN (geterror(ds))</programlisting>

        <variablelist>
          <varlistentry>
            <term>ds</term>

            <listitem>
              <para>A string containing the device spec to open, such
              as:</para>

              <screen>N:HTTPS://WWW.GNU.ORG/licenses/gpl-3.0.txt</screen>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>t</term>

            <listitem>
              <para>The translation mode to use where:<table>
                  <title>nopen Translation Values</title>

                  <tgroup cols="2">
                    <thead>
                      <row>
                        <entry align="center">t</entry>

                        <entry align="center">Description</entry>
                      </row>
                    </thead>

                    <tbody>
                      <row>
                        <entry>0</entry>

                        <entry>No Translation of end of line
                        (<acronym>EOL</acronym>) characters.</entry>
                      </row>

                      <row>
                        <entry>1</entry>

                        <entry>Translate EOL character to/from CR</entry>
                      </row>

                      <row>
                        <entry>2</entry>

                        <entry>Translate EOL character to/from LF</entry>
                      </row>

                      <row>
                        <entry>3</entry>

                        <entry>Translate EOL character to/from CR/LF
                        pair</entry>
                      </row>
                    </tbody>
                  </tgroup>
                </table></para>
            </listitem>
          </varlistentry>
        </variablelist>

        <tip>
          <para>the <function>nenableproc()</function> procedure can be used
          after <function>nopen()</function> to enable an interrupt which will
          set the variable trip to TRUE when traffic is available to
          read.</para>
        </tip>

        <example>
          <title>Opening a Connection in ACTION! Using nopen()</title>

          <programlisting>' 2 = use UNIX line endings.
nopen("N:HTTP://WWW.GNU.ORG/licenses/gpl-3.0",2);</programlisting>
        </example>
      </section>

      <section>
        <title>PROCEED Interrupt Handler</title>

        <para>The FujiNet signals incoming traffic via an interrupt on the
        <hardware>PROCEED</hardware> pin. This interrupt is edge triggered.
        The ATARI operating system has an interrupt vector called
        <varname>VPRCED</varname>, which is called from the operating system's
        <acronym>IRQ</acronym> handler. Using interrupts can drastically
        improve performance of interactive network applications by minimizing
        the number of polls needed to determine how many bytes are waiting in
        FujiNet's receive buffer.</para>

        <para>Not all programs need this functionality, so it may be omitted
        in cases where constant polling of the receive buffer isn't required.
        Such applications include those which use the <acronym>HTTP</acronym>
        protocol.</para>

        <para>To react to this interrupt, a handler needs to be placed in
        memory, and VPRCED's address vector needs to point to it. The
        following is a sample interrupt handler which sets a variable called
        trip to 1 whenever the PROCEED pin is changed in response to data
        being in the receive buffer:</para>

        <programlisting>;
; Interrupt handler
;
; A9 01    LDA #$01
; 8D XX XX STA trip
; 68       PLA
; 40       RTI
; 
PROC ninterrupt_handler=*()
[$A9$01$8D trip $68$40]</programlisting>

        <para><emphasis role="bold">The PROCEED interrupt will trigger if any
        active network devices have data in their respective receive
        buffers.</emphasis></para>
      </section>

      <section>
        <title>Enabling PROCEED Interrupt</title>

        <para>If you choose to use the <hardware>PROCEED</hardware> interrupt
        functionality, you should use this procedure to enable the interrupt
        safely and to properly reset the <varname>trip</varname> variable to
        zero:</para>

        <programlisting>;
; PROCEED interrupt vars
;
CARD VPRCEDSAVE     ; Save vector for vprced
CARD VPRCED = $0202 ; Proceed vector
BYTE PACTL  = $D302 ; PIA Control for Proceed
BYTE trip           ; Trip FLAG.

;
; Enable Interrupt handler.
;
PROC nenableproc()

    trip=0
    VPRCEDSAVE=VPRCED
    VPRCED=ninterrupt_handler
    PACTL = PACTL % 1

RETURN</programlisting>

        <para><important>
            <para>once <function>nenableproc()</function> is used,
            <function>ndisableproc()</function> must be called, either on
            closing of the network connection, or program. Otherwise,
            unpredictable system behavior may result! See Disabling
            <hardware>PROCEED</hardware> Interrupt.</para>
          </important></para>
      </section>

      <section>
        <title>Reading From a Connection</title>

        <para>The following function, called <function>nread()</function>, can
        read from a network connection that has been opened by the
        <function>nopen()</function> function:</para>

        <programlisting>;
; Read len bytes from N: device 
; pointed to by devicespec.
;
; @param devicespec N: devicespec
; @param buf The dest buffer
; @param len # of bytes to read
; @return error 1=successful
;
BYTE FUNC nread(BYTE ARRAY ds, BYTE ARRAY buf, CARD len)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'R    ; READ
  DSTATS = $40   ; Atari&lt;-Payload
  DBUF   = buf   ; send devicespec
  DTIMLO = $1F   ; 32 second timeout
  DBYT   = len   ; No payload
  DAUX   = len
  siov();  

RETURN (geterror(ds))
</programlisting>

        <variablelist>
          <varlistentry>
            <term>ds</term>

            <listitem>
              <para>The Device specification previously passed to
              <function>nopen()</function>, used to derive the network device
              unit number.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>buf</term>

            <listitem>
              <para>The byte array to place read characters into. Must be able
              to hold at least <varname>len</varname> number of bytes.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>len</term>

            <listitem>
              <para>The number of bytes to read (1-65535).</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para><warning>
            <para><varname>buf</varname> must be able to hold the number of
            bytes requested by <varname>len</varname>. <varname>Len</varname>
            must be less than, or equal to the number of bytes available in
            the receive buffer. Use <function>nstatus()</function> to
            determine the number of bytes available in the receive
            buffer.</para>
          </warning>For example, to read data from an open connection, while
        making sure to only read as much as is available, but not more than
        the target buffer can allow:</para>

        <example>
          <title>Reading from a Connection, in ACTION! using nread()</title>

          <programlisting>CARD bw = $02EA  ; DVSTAT
BYTE err

err = nstatus(url)

if err &lt;&gt; 1 then
    return
fi

if bw = 0 then
    return
fi

if bw &gt; 4096 then
    bw = 4096
fi

nread(url,buf,bw)
 </programlisting>
        </example>
      </section>

      <section>
        <title>Writing To a Connection</title>

        <para>The following function, called <function>nwrite()</function>,
        can write to a network connection that has been opened by the
        <function>nopen()</function> function.</para>

        <programlisting>;
; Write len bytes to N: device 
; pointed to by devicespec.
;
; @param devicespec N: devicespec
; @param buf The src buffer
; @param len # of bytes to read
; @return error 1=successful
;
BYTE FUNC nwrite(BYTE ARRAY ds, BYTE ARRAY buf, CARD len)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'W    ; WRITE
  DSTATS = $80   ; Payload-&gt;FujiNet
  DBUF   = buf   ; send devicespec
  DTIMLO = $1F   ; 32 second timeout
  DBYT   = len   ; No payload
  DAUX   = len
  siov();  

RETURN (geterror(ds))</programlisting>

        <variablelist>
          <varlistentry>
            <term>ds</term>

            <listitem>
              <para>The Device specification previously passed to
              <function>nopen()</function>, used to derive the network device
              unit number.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>buf</term>

            <listitem>
              <para>The byte array to read characters from. Must have at
              <varname>len</varname> number of bytes.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>len</term>

            <listitem>
              <para>The number of bytes to write. (1-65535).</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <warning>
          <para><varname>buf</varname> must contain at least the number of
          bytes specified by <varname>len</varname>.</para>
        </warning>

        <para>For example, to write data to an open connection:<example>
            <title>Writing to a Connection, in ACTION! using nwrite()</title>

            <programlisting>nwrite("Hello",5);</programlisting>
          </example></para>
      </section>

      <section>
        <title>Getting Connection Status</title>

        <para>The following function, called nstatus(), can return status
        information in a connection into the system variable DVSTAT, which
        exists at location $02EA, which includes:</para>

        <table>
          <title>Return Values in DVSTAT for nstatus()</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry align="center">Variable</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>CARD BW=$02EA</entry>

                <entry>The Number of bytes waiting in a connection's receive
                buffer.</entry>
              </row>

              <row>
                <entry>BYTE CONNECTED=$02EC</entry>

                <entry>Is the connection active? 1 = TRUE, 0 = FALSE</entry>
              </row>

              <row>
                <entry>BYTE ERROR=$02ED</entry>

                <entry>The error from the previous network operation.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <programlisting>CARD BW=$02EA
BYTE CONNECTED=$02EC
BYTE ERROR=$02ED

;
; Get status of last NIO operation,
; Return in DVSTAT
; 
; @param devicespec N: devicespec
;
PROC nstatus(BYTE ARRAY ds)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'S     ; STATUS
  DSTATS = $40    ; Payload to Atari
  DBUF   = $02EA  ; status buffer
  DTIMLO = $1F    ; 32 second timeout
  DBYT   = 4      ; 4 byte payload
  DAUX1  = 0      ; R/W
  DAUX2  = 0      ; translation
  siov()   

RETURN</programlisting>

        <variablelist>
          <varlistentry>
            <term>ds</term>

            <listitem>
              <para>The Device specification previously passed to
              <function>nopen()</function>, used to derive the network device
              unit number.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>For example, to check if an open connection has been
        disconnected:<example>
            <title>Getting Connection Status in ACTION! using
            nstatus()</title>

            <programlisting>BYTE CONNECTED=$02EC

nstatus("N:TELNET://BBS.FOZZTEXX.COM")

if (CONNECTED=0)
    EXIT()
fi</programlisting>
          </example></para>
      </section>

      <section>
        <title>Disabling PROCEED Interrupt</title>

        <para>If <function>nenableproc()</function> was used after opening a
        network connection, the following procedure
        <function>ndisableproc()</function> must be used to disable the
        interrupt before the program ends.</para>

        <programlisting>CARD VPRCEDSAVE

;
; Disable Interrupt handler.
;
PROC ndisableproc()

    trip=0
    VPRCED=VPRCEDSAVE

RETURN</programlisting>

        <important>
          <para>If <function>nenableproc()</function> is used, Failure to call
          <function>ndisableproc()</function> before program exit will result
          in unpredictable system operation!</para>
        </important>
      </section>

      <section>
        <title>Closing a Connection</title>

        <para>The following function, called nclose(), will close a connection
        previously opened with nopen():<programlisting>;
; Close the N: device pointed to by
; devicespec.
; 
; @param devicespec N: devicespec
; @return error, 1=successful.
;
BYTE FUNC nclose(BYTE ARRAY ds)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'C    ; CLOSE
  DSTATS = $00   ; No Payload
  DBUF   = 0     ; send devicespec
  DTIMLO = $1F   ; 32 second timeout
  DBYT   = 0     ; No payload
  DAUX1  = 0
  DAUX2  = 0
  siov();  

RETURN (geterror(ds))</programlisting></para>
      </section>

      <section>
        <title>Opening a Server (Listening) Connection</title>

        <para>If a host name is not specified in the URL passed to
        <function>nopen()</function>, FujiNet will attempt to open a server
        connection, which listens for connection attempts to a specific
        port.</para>

        <programlisting>' Open a TCP listening connection, on port 6502. No translation.
nopen("N:TCP://:6502/",0)</programlisting>
      </section>

      <section>
        <title>Checking for a Client Connection</title>

        <para>Once a server connection is opened,
        <function>nstatus()</function> can be used to populate the CONNECTED
        variable (which is located at DVSTAT+2), to determine if a connection
        is waiting to be accepted.<programlisting>BYTE CONNECTED=$02EC
BYTE ARRAY URL="N:TCP://:6502"

nstatus(url)

IF CONNECTED=1 THEN
    naccept(url); ' See Accepting a Client Connection
FI</programlisting></para>
      </section>

      <section>
        <title>Accepting a Client Connection</title>

        <para>The following procedure, called <function>naccept()</function>
        can be used to accept a client connection. The connection can
        immediately be treated as if it were a client
        connection:<programlisting>;
; Accept the Client Connection
;
; @param ds devicespec N: devicespec
;
BYTE FUNC naccept(BYTE ARRAY ds)
  DDEVIC=$71
  DUNIT=ngetunit(ds)
  DCOMND='A  ; Accept
  DSTATS=$00 ; No Payload
  DBUF=0     ; No Payload
  DTIMLO=$1F ; 32 second timeout
  DBYT=0     ; No payload
  DAUX1=0 
  DAUX2=0
  siov()

RETURN (geterror(ds))</programlisting></para>
      </section>

      <section>
        <title>Closing an Accepted Client Connection</title>

        <para>The following procedure can be used to close a client
        connection, while still keeping the listener connection open for
        another host to connect:</para>

        <programlisting>;
; Close the Client Connection
; Free the listening connection
; For further use.
;
; @param ds devicespec N: devicespec
;
BYTE FUNC ncloseclient(BYTE ARRAY ds)
  DDEVIC=$71
  DUNIT=ngetunit(ds)
  DCOMND='c  ; client close, lower case c
  DSTATS=$00 ; No Payload
  DBUF=0     ; No Payload
  DTIMLO=$1F ; 32 second timeout
  DBYT=0     ; No payload
  DAUX1=0 
  DAUX2=0
  siov()

RETURN (geterror(ds))</programlisting>
      </section>

      <section>
        <title>Closing the Server (Listening) Connection</title>

        <para>Closing the server listening connection, should be done when the
        program no longer needs to listen as a server for remote connections.
        nclose() is used for this purpose:<programlisting>BYTE ARRAY url="N:TCP://:6502"

nclose(url)</programlisting></para>
      </section>

      <section>
        <title>NIO.ACT Library Listing</title>

        <para>NIO.ACT is an ACTION! Library that exposes FujiNet functions via
        SIO calls. It also provides an interrupt handler routine that improves
        performance by minimizing status polling.</para>

        <para>This library may be fetched directly on-line via the URL: <link
        xlink:href="https://raw.githubusercontent.com/FujiNetWIFI/fujinet-apps/master/netcat-action/NIO.ACT">https://raw.githubusercontent.com/FujiNetWIFI/fujinet-apps/master/netcat-action/NIO.ACT</link></para>

        <programlisting linenumbering="numbered">;
; #FujiNet Network I/O Library    
; For ACTION!
;
; Author: Thomas Cherryhomes
;  &lt;thom.cherryhomes@gmail.com&gt;
;
; These routines call the #Fujinet
; directly from SIO, and thus do
; not need the N: handler (NDEV)
;

MODULE

;
; PROCEED interrupt vars
;
CARD VPRCEDSAVE     ; Save vector for vprced
CARD VPRCED = $0202 ; Proceed vector
BYTE PACTL  = $D302 ; PIA Control for Proceed
BYTE trip           ; Trip FLAG.

;
; DVSTAT (Status)
;
BYTE DVSTAT = $02EA ; PTR TO DVSTAT
BYTE EXTERR = $02ED ; DVSTAT+3

;
; DEVICE CONTROL BLOCK (DCB)
;
BYTE DDEVIC = $0300 ; Device #
BYTE DUNIT  = $0301 ; Unit #
BYTE DCOMND = $0302 ; Command
BYTE DSTATS = $0303 ; &lt;-&gt; and error
CARD DBUF   = $0304 ; buffer
BYTE DTIMLO = $0306 ; timeout secs
BYTE DUNUSE = $0307 ; reserved
CARD DBYT   = $0308 ; pyld byte len
CARD DAUX   = $030A ; daux1/daux2
BYTE DAUX1  = $030A ; daux1
BYTE DAUX2  = $030B ; daux2

;
; Interrupt handler
;
; A9 01    LDA #$01
; 8D XX XX STA trip
; 68       PLA
; 40       RTI
; 
PROC ninterrupt_handler=*()
[$A9$01$8D trip $68$40]

;
; Enable Interrupt handler.
;
PROC nenableproc()

    trip=0
    VPRCEDSAVE=VPRCED
    VPRCED=ninterrupt_handler
    PACTL = PACTL % 1

RETURN

;
; Disable Interrupt handler.
;
PROC ndisableproc()

    trip=0
    VPRCED=VPRCEDSAVE

RETURN

;
; PROC to call SIO Vector (SIOV)
;
PROC siov=$E459()

;
; Get the unit number from devicespec
;
BYTE FUNC ngetunit(BYTE ARRAY ds)
    BYTE unit=1
                   
    IF ds(2)=': THEN
        unit=1
    ELSEIF ds(3)=': THEN
        unit=ds(2)-$30
    ELSE
        unit=1
    FI

RETURN (unit)

;
; Get status of last NIO operation,
; Return in DVSTAT
; 
; @param devicespec N: devicespec
;
PROC nstatus(BYTE ARRAY ds)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'S     ; STATUS
  DSTATS = $40    ; Payload to Atari
  DBUF   = $02EA  ; status buffer
  DTIMLO = $1F    ; 32 second timeout
  DBYT   = 4      ; 4 byte payload
  DAUX1  = 0      ; R/W
  DAUX2  = 0      ; translation
  siov()   

RETURN

;
; Return error of last NIO operation.
; If SIO error = 144, then a status
; is done, and the extended err is 
; returned.
;
; @param devicespec N: devicespec
; @return error 1=successful
;
BYTE FUNC geterror(BYTE ARRAY ds)
  BYTE errno

  IF DSTATS=144 THEN
    nstatus(ds)
    errno=EXTERR
  ELSE
    errno=DSTATS
  FI

RETURN (errno)

;
; Open the N: device pointed to by
; devicespec.
; 
; @param devicespec N: devicespec
; @param trans - translation mode
;   0=NONE, 1=CR, 2=LF, 3=CR/LF
; @return error, 1=successful.
;
BYTE FUNC nopen(BYTE ARRAY ds, BYTE t)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'O    ; OPEN
  DSTATS = $80   ; Write to fujinet
  DBUF   = ds    ; send devicespec
  DTIMLO = $1F   ; 32 second timeout
  DBYT   = 256   ; 256 byte payload
  DAUX1  = 12    ; R/W
  DAUX2  = t     ; translation
  siov();  

  IF DSTATS=1 THEN
      nenableproc()
  FI

RETURN (geterror(ds))

;
; Close the N: device pointed to by
; devicespec.
; 
; @param devicespec N: devicespec
; @return error, 1=successful.
;
BYTE FUNC nclose(BYTE ARRAY ds)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'C    ; CLOSE
  DSTATS = $00   ; No Payload
  DBUF   = 0     ; send devicespec
  DTIMLO = $1F   ; 32 second timeout
  DBYT   = 0     ; No payload
  DAUX1  = 0
  DAUX2  = 0
  siov();  

  ndisableproc()

RETURN (geterror(ds))

;
; Read len bytes from N: device 
; pointed to by devicespec.
;
; @param devicespec N: devicespec
; @param buf The dest buffer
; @param len # of bytes to read
; @return error 1=successful
;
BYTE FUNC nread(BYTE ARRAY ds, BYTE ARRAY buf, CARD len)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'R    ; READ
  DSTATS = $40   ; Atari&lt;-Payload
  DBUF   = buf   ; send devicespec
  DTIMLO = $1F   ; 32 second timeout
  DBYT   = len   ; No payload
  DAUX   = len
  siov();  

RETURN (geterror(ds))

;
; Write len bytes to N: device 
; pointed to by devicespec.
;
; @param devicespec N: devicespec
; @param buf The src buffer
; @param len # of bytes to read
; @return error 1=successful
;
BYTE FUNC nwrite(BYTE ARRAY ds, BYTE ARRAY buf, CARD len)

  DDEVIC = $71
  DUNIT  = ngetunit(ds)
  DCOMND = 'W    ; WRITE
  DSTATS = $80   ; Payload-&gt;FujiNet
  DBUF   = buf   ; send devicespec
  DTIMLO = $1F   ; 32 second timeout
  DBYT   = len   ; No payload
  DAUX   = len
  siov();  

RETURN (geterror(ds))

; Get FujiNet Status
;
; Author: Michael Goroll
;  &lt;atari@goroll.net&gt;
;
PROC fstatus(BYTE ARRAY buf)

DDEVIC = $70
DUNIT  = $01
DCOMND = $E8
DSTATS = $40    ; Payload to Atari
DBUF   = buf    ; status buffer
DTIMLO = $0F    ; 8 second timeout
DBYT   = $88    ; 139 byte payload
DAUX1  = 0      ; R/W
DAUX2  = 0      ; translation
siov()

RETURN</programlisting>
      </section>

      <section>
        <title>Example Programs</title>

        <para>The following programs are listed here for easy
        reference.</para>

        <para>They are loadable via TNFS on apps.irata.online, in the
        directory: /Atari_8-bit/Internet/ as:</para>

        <itemizedlist>
          <listitem>
            <para>Netcat (Action).atr</para>
          </listitem>

          <listitem>
            <para>Mastodon (Action).atr</para>
          </listitem>
        </itemizedlist>

        <section>
          <title>NETCAT: A Simple Terminal Emulator</title>

          <para>NETCAT is a program which acts like a simple dumb terminal
          emulator. It will read and display any information that appears on
          the network channel, while also checking for key presses and sending
          them out the same network channel. This will continue until either
          the host disconnects, or a network error occurs. In either case, the
          network channel is closed, and the program ends.</para>

          <example>
            <title>NETCAT ACTION! Listing</title>

            <programlisting linenumbering="numbered">; 
; A simple netcat program
; to show how to do basic network
; input and output.
;
; Author: Thomas Cherryhomes
;  &lt;thom.cherryhomes@gmail.com&gt;
;

INCLUDE "D2:SYS.ACT"
INCLUDE "D2:NIO.ACT"

MODULE

CARD BYTESWAITING=$02EA     ; # of bytes waiting
BYTE KP=$02FC               ; Key pressed?
BYTE ARRAY devicespec(256)  ; DeviceSpec
BYTE trans                  ; translation mode
BYTE localEcho              ; local echo off/on?
BYTE running                ; is program running?
BYTE ARRAY rxbuf(8192)      ; receive buffer

DEFINE KEYBOARD_IOCB="2"
DEFINE TRUE="1"
DEFINE FALSE="0"

;
; Prompt for URL
;
PROC getURL()
       PrintE("NETCAT--ENTER DEVICE SPEC?")
       InputS(devicespec)
       PutE()
       
       PrintE("TRANS--0=NONE, 1=CR, 2=LF, 3=CR/LF?")
       trans=InputB()
       PutE()

       PrintE("LOCAL ECHO--0=NO, 1=YES?")
       localEcho=InputB()
       PutE()
RETURN

;
; Handle nc output
;
PROC ncoutput()
       BYTE ARRAY ch(1)
       BYTE err

       IF KP=$FF THEN
           RETURN
       FI

       ch(0)=GetD(KEYBOARD_IOCB)

       IF localEcho=1 THEN
           Put(ch(0))
       FI

       err=nwrite(devicespec,ch,1)

       IF err&lt;&gt;1 THEN
           Print("Write Error: ")
           PrintB(err)
           running=FALSE
       FI

RETURN

;
; Handle nc input
;
PROC ncinput()
       BYTE err
       CARD I

       IF trip=0 THEN
           RETURN
       FI

       nstatus()

       IF EXTERR=136 THEN
          PrintE("Disconnected.")
          running=FALSE
          RETURN
       FI

       IF BYTESWAITING=0 THEN
          RETURN 
       FI

       IF BYTESWAITING&gt;8192 THEN
          BYTESWAITING=8192
       FI

       ; Do the network read.
       err=nread(devicespec,rxbuf,BYTESWAITING)

       IF err&lt;&gt;1 THEN
           Print("Read Error: ")
           PrintB(err)
           running=FALSE
           RETURN
       FI
       
       ; Drain/display rx buffer
       FOR I=0 TO BYTESWAITING-1
       DO
           Put(rxbuf(I))
       OD

       ; Done, reset interrupt
       trip=0
       PACTL=PACTL%1

RETURN

;
; The main Netcat function
;
PROC nc()
       BYTE err

       err=nopen(deviceSpec,trans)

       IF err&lt;&gt;1 THEN
           Print("Open Error: ")
           PrintB(err)
           RETURN
       FI

       ; flag program as running.
       running=1
               
       ; Open keyboard
       Open(KEYBOARD_IOCB,"K:",4,0)

       WHILE running = TRUE  
         DO
         ncoutput()
         ncinput()
         OD

       PrintE("Bye.")

       ; Clean up
       Close(KEYBOARD_IOCB) ; close kybd
       nclose(deviceSpec)

RETURN

;
; Main entrypoint
;
PROC main()
       getURL()
       nc()
RETURN</programlisting>
          </example>
        </section>

        <section>
          <title>MASTODON: Show the Newest Mastodon Post</title>

          <programlisting linenumbering="numbered">; A SIMPLE MASTODON CLIENT
; SHOWS THE LATEST POST     
; FROM OLDBYTES.SPACE

INCLUDE "D1:SYS.ACT"
INCLUDE "D1:NIO.ACT"

MODULE

BYTE ARRAY URL(256)
BYTE ARRAY QS(256)
BYTE CONSOL=$D01F
BYTE CLOK0=$12
BYTE CLOK1=$13
BYTE CLOK2=$14
CARD BW=$02EA

; PRINT RESULT OF JSON QUERY
; _qs = Query String
PROC PRINTJ(BYTE ARRAY _qs)
    BYTE ERR
    BYTE ARRAY OUT(4096)
    CARD X

    SCOPY(QS,_qs)

    ; get length of string
    ; append EOL
    X=QS(0)
    QS(X+1)=155

    ; perform query
    ERR = NQUERYJSON(URL,QS)

    IF ERR&lt;&gt;1 THEN
       PRINT("QUERY ERROR: ")
       PRINTB(ERR)
       RETURN
    FI

    ; Get # of bytes waiting...
    NSTATUS(URL)

    IF ERR&lt;&gt;1 THEN
       PRINT("STATUS ERROR: ");
       PRINTBE(ERR)
       RETURN
    FI

    ; Read result into OUT
    ERR = NREAD(URL,OUT,BW)

    IF ERR&lt;&gt;1 THEN
       PRINT("READ ERROR: ")
       PRINTBE(ERR)
       RETURN
    FI 

    ; Display it, one byte at a time
    FOR X=0 TO BW-1
    DO
        PUT(OUT(X))
    OD
        
RETURN

PROC FOOTER()
    PRINTE("")
    PRINTE("-------------------------------------")
    PRINTE("")
RETURN

PROC BANNER()
    FOOTER()
    PRINTE("LATEST POST FROM:")
    PRINTE(" OLDBYTES.SPACE ")
    FOOTER()
RETURN

PROC SHOW_POST()
    BYTE ERR    

    SCOPY(URL,"N:HTTPS://oldbytes.space/api/v1/timelines/public?limit=1")

    ERR=NOPEN(URL,0)

    IF ERR&lt;&gt;1 THEN
       PRINT("OPEN ERROR: ")
       PRINTBE(ERR)
       RETURN
    FI

    NCHANNELMODE(URL,1)

    ERR=NPARSEJSON(URL)

    IF ERR&lt;&gt;1 THEN
       PRINT("PARSE ERROR: ")
       PRINTBE(ERR)
       RETURN
    FI    

    PRINTJ("N:/0/account/display_name")
    PRINTJ("N:/0/created_at");
    PRINTJ("N:/0/content");

    NCLOSE(URL)

RETURN                     

PROC MAIN()

    BANNER()
    SHOW_POST()
    FOOTER()

RETURN
</programlisting>
        </section>
      </section>
    </chapter>

    <chapter>
      <title>Assembler</title>

      <para/>
    </chapter>

    <chapter>
      <title>FORTH</title>

      <para/>
    </chapter>

    <chapter>
      <title>C</title>

      <subtitle>(using CC65)</subtitle>

      <para/>
    </chapter>

    <chapter>
      <title>Pascal</title>

      <subtitle>(using Mad Pascal)</subtitle>

      <para/>
    </chapter>
  </part>

  <part>
    <title>REFERENCE</title>

    <chapter>
      <title>FujiNet Configuration Tools</title>

      <section>
        <title><command>FCONFIG</command></title>

        <subtitle>Show Network Configuration</subtitle>

        <synopsis><command>FCONFIG</command></synopsis>

        <simplesect>
          <title>Description</title>

          <para><command>FCONFIG</command> reads the adapter configuration
          from FujiNet and displays it.</para>

          <para>It currently displays:</para>

          <itemizedlist>
            <listitem>
              <para>Wireless Network <acronym>SSID</acronym></para>
            </listitem>

            <listitem>
              <para>Host name</para>
            </listitem>

            <listitem>
              <para>Local IP address</para>
            </listitem>

            <listitem>
              <para>Gateway IP address</para>
            </listitem>

            <listitem>
              <para><acronym>DNS</acronym> IP address</para>
            </listitem>

            <listitem>
              <para>Netmask</para>
            </listitem>

            <listitem>
              <para>Hardware (<acronym>MAC</acronym>) address</para>
            </listitem>

            <listitem>
              <para><acronym>BSSID</acronym></para>
            </listitem>

            <listitem>
              <para><command>FCONFIG</command> Version</para>
            </listitem>

            <listitem>
              <para>FujiNet Firmware Version</para>
            </listitem>
          </itemizedlist>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para>This command has no parameters.</para>
        </simplesect>

        <simplesect>
          <title>Messages</title>

          <para><command>FCONFIG</command> displays output similar to the
          following:</para>

          <screen>
D1:<command>FCONFIG</command>

           SSID: Dummy Cafe
       Hostname: TMA-2
     IP Address: 127.0.0.1
Gateway Address: 0.0.0.0
    DNS Address: 1.1.1.1
        Netmask: 255.0.0.0
    MAC Address: D0:1C:ED:C0:FF:EE
          BSSID: D0:1C:ED:C0:FF:EE
FCONFIG Version: 0.1.7643858
  Fuji Firmware: v1.2

D1:

</screen>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Returns 0 on success. Otherwise the SIO error code is
          returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FEJECT</command></title>

        <subtitle>Eject disk image in specified slot</subtitle>

        <synopsis><command>FEJECT</command> <parameter>&lt;ds#&gt;</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Ejects the disk image specified by the device slot. A
          notification is displayed if there is no disk image in the specified
          slot.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <variablelist>
            <varlistentry>
              <term>ds#</term>

              <listitem>
                <para>The device slot # (1-8)</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </simplesect>

        <simplesect>
          <title>Messages</title>

          <para>On success, the following is displayed:</para>

          <screen>Disk D3: ejected.</screen>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FHOST</command></title>

        <subtitle>Edit or clear a host slot</subtitle>

        <synopsis><command>FHOST</command> <parameter>&lt;hs#&gt;</parameter><parameter>[,hostname]</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>If a host name is specified, it will change the host name of
          the specified host slot, otherwise the host slot is cleared.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term>&lt;hs#&gt;</term>

                <listitem>
                  <para><emphasis>Required.</emphasis> The host slot #
                  (1-8)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>[hostname]</term>

                <listitem>
                  <para>The host name to set.</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>Setting Host Slot #4 with FHOST</title>

            <para>To set host slot #4 to 192.168.1.8:</para>

            <screen><command>FHOST</command> <parameter>4</parameter>,<parameter>192.168.1.8</parameter></screen>
          </example>

          <example>
            <title>Clearing Host Slot #4 with FHOST</title>

            <para>To clear the host name in slot #4:</para>

            <screen><command>FHOST</command> 4</screen>
          </example>
        </simplesect>

        <simplesect>
          <title>Messages:</title>

          <para>If a host entry is changed:</para>

          <screen>Host Slot #4 changed to:
192.168.1.8</screen>

          <para>If a host entry is cleared:</para>

          <screen>Host slot #4 cleared.</screen>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FINFO</command></title>

        <subtitle>Show disk info for given Device Slot</subtitle>

        <synopsis><command>FINFO</command> <parameter>&lt;ds&gt;</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Shows the disk geometry of a disk image inserted into the
          specified device slot.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>&lt;ds#&gt;</parameter></term>

                <listitem>
                  <para><emphasis>Required.</emphasis> The device slot #
                  (1-8)</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Example</title>

          <example>
            <title>Showing Disk Info in Slot 1 with FINFO</title>

            <screen>
D1:<command>FINFO</command> <parameter>1</parameter>

Number of Tracks: 40
Sectors per Track: 18
Number of Sides: 1
Sector Size: 256

Disk Type: 180K SS/DD
				</screen>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Returns 0 on success. Otherwise the SIO error code is
          returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FLD</command></title>

        <subtitle>List Device Slots</subtitle>

        <synopsis><command>FLD</command></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Displays the images mounted in each of the possible device
          slots D1: to D8:. Each entry shows the following information:</para>

          <itemizedlist>
            <listitem>
              <para>Device Slot</para>
            </listitem>

            <listitem>
              <para>Host Slot</para>
            </listitem>

            <listitem>
              <para>File Mode (R = Read, W = Write)</para>
            </listitem>

            <listitem>
              <para>File Name</para>
            </listitem>
          </itemizedlist>
        </simplesect>

        <simplesect>
          <title>Example</title>

          <example>
            <title>FLD Output</title>

            <screen>D1:<command>FLD</command>

D1: (3) (R) OSS DOS XL 2.30p.atr
D2: (3) (R) fnc-tools-doc.atr
D3: Empty
D4: Empty
D5: Empty
D6: Empty
D7: Empty
D8: Empty</screen>

            <para>This example shows two disk images, D1 and D2. Both disk
            images are mounted from host slot (3). Both are mounted (R)ead
            only.</para>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, otherwise the SIO error is
          returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FLH</command></title>

        <subtitle>List Host Slots</subtitle>

        <synopsis><command>FLH</command></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Displays the host names in each of the eight host slots.
          "Empty" is displayed, if a host slot is not being used.</para>
        </simplesect>

        <simplesect>
          <title>Example</title>

          <example>
            <title>Listing Host Slots with FLH</title>

            <screen>D1:<command>FLH</command>

1: SD
2: tnfs.fujinet.online
3: apps.irata.online
4: fujinet.atari8bit.net
5: fujinet.pl
6: tma-2
7: Empty
8: ec.tnfs.io</screen>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0, on success. Otherwise, the SIO error code is
          returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FLS</command></title>

        <subtitle>List files on a Host Slot</subtitle>

        <synopsis>FLS <parameter>&lt;hs#&gt;</parameter>,<parameter>&lt;path&gt;</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Lists files present on the server at the specified host slot,
          and path.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <variablelist>
            <varlistentry>
              <term><parameter>&lt;hs#&gt;</parameter></term>

              <listitem>
                <para>Required. The Host Slot to list. (1-8)</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><parameter>&lt;path&gt;</parameter></term>

              <listitem>
                <para>Required. The path to list. Use '/' for the root
                directory.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </simplesect>

        <simplesect>
          <title>Example</title>

          <example>
            <title>Listing a server directory, using FLS</title>

            <screen>D1:<command>FLH</command>

1: SD
2: tnfs.fujinet.online
3: apps.irata.online
4: fujinet.atari8bit.net
5: fujinet.pl
6: tma-2
7: Empty
8: ec.tnfs.io

D1:<command>FLS</command> 2,/
ADAM/
APPLEII/
ATARI/
CBM/
TNFS-links/</screen>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FMALL</command></title>

        <subtitle>Mount All Device Slots</subtitle>

        <synopsis><command>FMALL</command></synopsis>

        <simplesect>
          <title>Description</title>

          <para><command>FMALL</command> reads the currently saved device
          slots and mounts them all.</para>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Returns 0 on success, otherwise the SIO error is
          returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FMOUNT</command></title>

        <subtitle>Mount a Disk Image</subtitle>

        <synopsis><command>FMOUNT</command> <parameter>&lt;ds#&gt;</parameter>,<parameter>&lt;hs#&gt;</parameter>,<parameter>&lt;R|W&gt;</parameter>,<parameter>&lt;path&gt;</parameter> </synopsis>

        <simplesect>
          <title>Description</title>

          <para>Mounts a disk image from the server specified by host slot, to
          the specified device slot, with the appropriate mode (read or
          write).</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <variablelist>
            <varlistentry>
              <term>ds#</term>

              <listitem>
                <para>The Device Slot # to use (1-8)</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>hs#</term>

              <listitem>
                <para>The Host Slot # to use (1-8)</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>R|W</term>

              <listitem>
                <para>The image mode. R = Read Only, W = Read/Write</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </simplesect>

        <simplesect>
          <title>Example</title>

          <para>To mount <filename>MyDOS 4.53.atr</filename> from host slot 6,
          into Drive Slot 2:</para>

          <example>
            <title>Mounting a disk with FMOUNT</title>

            <screen>D1:FLH

1: SD
2: tnfs.fujinet.online
3: apps.irata.online
4: fujinet.atari8bit.net
5: fujinet.pl
6: tma-2
7: Empty
8: ec.tnfs.io


D1:FLS 6,/
fastbasic.atr
Mastodon (ACTION!).atr
MASTODON.ACT
netcat-action.atr
NIO.ACT
Web_Server_example.atr

D1:FMOUNT 2,3,R,netcat-action.atr
D2: (3) (R) netcat-action.atr</screen>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, else the
          SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title>FNET</title>

        <subtitle>Connect to SSID with Password</subtitle>

        <synopsis>FNET [ssid] [password]</synopsis>

        <simplesect>
          <title>Description</title>

          <para>Connects to the specified wireless network, with the specified
          password. Password is optinal. If SSID isn't specified, then the
          last successful SSID is used.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <variablelist>
            <varlistentry>
              <term>[ssid]</term>

              <listitem>
                <para><emphasis>Optional</emphasis>. Specifies
                <acronym>SSID</acronym> to connect FujiNet to.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[password]</term>

              <listitem>
                <para><emphasis>Optional</emphasis>. Specifies password to
                use.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>...</para>
        </simplesect>
      </section>

      <section>
        <title><command>FNEW</command></title>

        <subtitle>Create a New Disk Image</subtitle>

        <synopsis><command>FNEW</command> <parameter>&lt;ds#&gt;</parameter>,<parameter>&lt;hs#&gt;</parameter>,<parameter>&lt;t&gt;</parameter>,<parameter>&lt;filename&gt;</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Creates a new disk image on the desired host, with the
          requested geometry and mounts it into the requested device slot, in
          read/write mode.</para>

          <para>The resulting disk image is blank, and has no file system,
          therefore it must be formatted by the desired operating system,
          before use.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>ds#</parameter></term>

                <listitem>
                  <para>Device slot # to use (1-8)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><parameter>hs#</parameter></term>

                <listitem>
                  <para>Host Slot # to place new disk image in (1-8)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><parameter>t</parameter></term>

                <listitem>
                  <para>Disk image type, where t can be:</para>
                </listitem>
              </varlistentry>
            </variablelist></para>

          <table>
            <title>FNEW Disk types</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="center">t</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>1</entry>

                  <entry>90K (SS/SD)</entry>
                </row>

                <row>
                  <entry>2</entry>

                  <entry>140K (SS/ED)</entry>
                </row>

                <row>
                  <entry>3</entry>

                  <entry>180K (SS/DD)</entry>
                </row>

                <row>
                  <entry>4</entry>

                  <entry>360K (DS/DD)</entry>
                </row>

                <row>
                  <entry>5</entry>

                  <entry>720K (DS/QD)</entry>
                </row>

                <row>
                  <entry>6</entry>

                  <entry>1440K (DS/HD)</entry>
                </row>

                <row>
                  <entry>1-65535:128|256</entry>

                  <entry>Custom, specify # of sectors and sector size.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </simplesect>

        <simplesect>
          <title>Messages</title>

          <para>If the disk image is successfully mounted, the new device slot
          information will be displayed.<screen>D2: (3) (W) newdisk.atr</screen></para>

          <para>Otherwise, an error message will be displayed.</para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>Creating a 90K disk with <command>FNEW</command></title>

            <para>This example places a 90K disk in device slot 3 (D3:), and
            places the image file on slot 1, which as seen by the output of
            <command>FLH</command>, is the SD card slot.<screen>D1:<command>FLH</command>

1: SD
2: tnfs.fujinet.online
3: apps.irata.online
4: fujinet.atari8bit.net
5: fujinet.pl
6: Empty
7: Empty
8: Empty

D1:<command>FNEW</command> <parameter>3</parameter>,<parameter>1</parameter>,<parameter>1</parameter>,<filename>BLAH1.ATR</filename>

CREATING DISK
D3: (1) (W) <filename>BLAH1.ATR</filename></screen></para>
          </example>

          <example>
            <title>Creating a 16MB disk with <command>FNEW</command></title>

            <para>This example places a 16 megabyte disk, made up of 65535
            sectors, 256 bytes each, in device slot 4 (D4:), and places the
            image file on slot 1, assuming the same output of FLH as above, is
            the SD card slot.</para>

            <screen>D1:<command>FNEW</command> <parameter>3</parameter>,<parameter>1</parameter>,<parameter>65535:256</parameter>,<filename>16MEG.ATR</filename></screen>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FRESET</command></title>

        <subtitle>Reset FujiNet and do a Cold Start</subtitle>

        <synopsis><command>FRESET</command></synopsis>

        <simplesect>
          <title>Description</title>

          <para>This command tells the FujiNet to reset itself. After waiting
          a few moments, the <trademark class="registered">ATARI</trademark>
          is cold started.</para>
        </simplesect>
      </section>

      <section>
        <title><command>FSCAN</command></title>

        <subtitle>Scan for Wireless Networks</subtitle>

        <synopsis><command>FSCAN</command></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Tells FujiNet to scan for wireless networks, and display their
          names. You can use <command>FNET</command> to connect to an SSID
          returned by <command>FSCAN</command>.</para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>Example run of <command>FSCAN</command></title>

            <para><screen>D1:<command>FSCAN</command>

* Cherryhomes
* TomsNetwork
* SomebodyElse
* AndAnother1234</screen></para>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>NCD</command></title>

        <subtitle>Change N: Prefix</subtitle>

        <synopsis><command>NCD</command> <parameter>[Nx:]</parameter><parameter>&lt;path&gt;</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>This command is used to set a path which is always prepended
          before user input, such as to change the currently active directory
          on a network file system, or to set a consistent host name for
          <acronym>TCP</acronym> or <acronym>UDP</acronym> connections.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>[Nx:]</parameter></term>

                <listitem>
                  <para>Set the prefix for the specified network device (N1:
                  to N8:)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><parameter>&lt;path&gt;</parameter></term>

                <listitem>
                  <para>Set the new prefix, according to the following
                  rules:<itemizedlist>
                      <listitem>
                        <para>If <parameter>&lt;path&gt;</parameter> contains
                        a protocol, such as N:<acronym>HTTP</acronym>:// then
                        the entire prefix is re-set absolutely.</para>
                      </listitem>

                      <listitem>
                        <para>If <parameter>&lt;path&gt;</parameter> is
                        <parameter>Nx:/</parameter> then the prefix is
                        truncated to the end of the current host name, so
                        <filename>N:TNFS://APPS.IRATA.ONLINE/ATARI_8-BIT/Games</filename>
                        becomes
                        <filename>N:TNFS://APPS.IRATA.ONLINE/</filename></para>
                      </listitem>

                      <listitem>
                        <para>If <parameter>&lt;path&gt;</parameter> is
                        <parameter>Nx:</parameter> then the prefix is cleared
                        completely.</para>
                      </listitem>

                      <listitem>
                        <para>If <parameter>Nx:</parameter> is not specified,
                        then <filename>N1:</filename> is assumed.</para>
                      </listitem>

                      <listitem>
                        <para>If no protocol is specified, and
                        <filename>/</filename> is the first character, then
                        the path after the host name is set to the new value,
                        so given a current prefix of
                        <filename>N:TNFS://APPS.IRATA.ONLINE/DOS/</filename>
                        and <filename>N:/Games</filename> is given, then the
                        new prefix will be
                        <filename>N:TNFS://APPS.IRATA.ONLINE/Games/</filename></para>
                      </listitem>

                      <listitem>
                        <para>If no protocol is specified, and the first
                        character is alphanumeric, then the given value is
                        appended to the current prefix. So, if the prefix is
                        currently
                        <filename>N:TNFS://APPS.IRATA.ONLINE/</filename> and
                        <filename>Games/</filename> is given, the new prefix
                        will be
                        <filename>N:TNFS://APPS.IRATA.ONLINE/Games/</filename></para>
                      </listitem>

                      <listitem>
                        <para>If two periods are specified, then the prefix
                        will have one path component removed, usually leading
                        to the parent directory.</para>
                      </listitem>
                    </itemizedlist></para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>Setting Network Prefix with <command>NCD</command></title>

            <para><screen>D1:NCD N:TNFS://APPS.IRATA.ONLINE/

D1:NPWD
TNFS://APPS.IRATA.ONLINE/

D1:NDIR N:
APPLE_II/                         76
APPLE_III/                       126
ATARI_8-BIT/                     604
COCO/                            268
COLECO_ADAM/                     164
commodore/                        46
Macintosh/                       198
tmp/                             106
boot.zx                          934
plato.tap                        26K
999+FREE SECTORS</screen></para>
          </example>

          <example>
            <title>Adding to Network Prefix with
            <command>NCD</command></title>

            <screen>D1:NCD N:ATARI_8-BIT

D1:NPWD
TNFS://APPS.IRATA.ONLINE/ATARI_8-BIT/

D1:NDIR N:
BBS/                              64
Comms/                           328
Databases/                       104
Demos/                            24
DOS/                             514
Educational/                      24
Games/                           764
Graphics/                         30
incoming/                         22
Internet/                        368
Languages/                       128
Mocks/                            80
Music/                           120
N-Demos/                          48
NOS/                              20
Novelties/                        92
PrintShop/                        82
Spreadsheets/                     58
Tests/                            18
TimeMgmt/                         48
Utils/                           178
WordProc/                        218
fnc-tools-doc.atr                90K
fnc-tools.atr                    90K
fujinet-dosxl-tools.atr          90K
FujiNetToolsSpartaDOS.atr        90K
FujiNetToolsSpartaDOSSource.atr
90K
n-handler.atr                    90K
SDX449_ULTIMATE1MB_FUJINET.ATR 1000K
999+FREE SECTORS</screen>
          </example>

          <example>
            <title>Using <command>NCD</command> with '..' for Parent
            Directory</title>

            <screen>D1:NPWD
TNFS://APPS.IRATA.ONLINE/ATARI_8-BIT/

D1:NCD N:..

D1:NPWD
TNFS://APPS.IRATA.ONLINE/</screen>
          </example>

          <example>
            <title>Using NCD to Return to Root Directory</title>

            <screen>D1:NPWD
TNFS://APPS.IRATA.ONLINE/ATARI_8-BIT/Games/Homesoft/A/

D1:NCD N:/

D1:NPWD
TNFS://APPS.IRATA.ONLINE/</screen>
          </example>

          <example>
            <title>Using NCD to reset path relative to Root Directory</title>

            <screen>D1:NPWD
TNFS://APPS.IRATA.ONLINE/ATARI_8-BIT/Games/Homesoft/A/

D1:NCD N:/ATARI_8-BIT/DOS/

D1:NPWD
TNFS://APPS.IRATA.ONLINE/ATARI_8-bit/DOS/</screen>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>NCOPY</command></title>

        <subtitle>Copy files to and from disk or network.</subtitle>

        <synopsis><command>NCOPY</command> <parameter>&lt;src&gt;</parameter>,<parameter>&lt;dest&gt;</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Copies files from source to destination.</para>

          <para>Source and destination can be:</para>

          <itemizedlist>
            <listitem>
              <para>Any <acronym>CIO</acronym> device like
              <filename>D:</filename> or <filename>E:</filename></para>
            </listitem>

            <listitem>
              <para>Any Network Device <filename>N:</filename></para>
            </listitem>
          </itemizedlist>

          <para>If an <filename>N:</filename> device is specified as either a
          source or a destination, <command>NCOPY</command> will talk to
          #FujiNet directly over <acronym>SIO</acronym>, otherwise
          <acronym>CIO</acronym> calls are used.</para>
        </simplesect>

        <simplesect>
          <title>Devicespec for N: Device:</title>

          <para>The <filename>N:</filename> devicespec is defined as
          follows:</para>

          <para><filename>N[x]:&lt;proto&gt;://&lt;host&gt;[:port]/[path]</filename></para>

          <para>where:</para>

          <itemizedlist>
            <listitem>
              <para><filename>[x]</filename> is an optional device
              number.</para>
            </listitem>

            <listitem>
              <para><filename>&lt;proto&gt;</filename> specifies the
              protocol.</para>
            </listitem>

            <listitem>
              <para><filename>&lt;host&gt;</filename> the host name or
              address.</para>
            </listitem>

            <listitem>
              <para><filename>[:port]</filename> is a : followed by port
              #.</para>
            </listitem>

            <listitem>
              <para><filename>[path]</filename> is an optional path.<important>
                  <para>Any directory specified by <filename>NCD</filename>
                  will automatically be prepended to the beginning of the
                  <filename>N:</filename> devicespec.</para>
                </important></para>
            </listitem>
          </itemizedlist>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>&lt;src&gt;</parameter></term>

                <listitem>
                  <para>The source devicespec.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><parameter>&lt;dst&gt;</parameter></term>

                <listitem>
                  <para>The destination devicespec</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>Copying a file from disk, to the network</title>

            <screen>D1:<command>NCD</command> <parameter>N:TNFS://MYSERVER/WORK/</parameter>

D1:<command>NCOPY</command> <parameter>D1:FOO.TXT,N:BAR.TXT</parameter></screen>
          </example>

          <example>
            <title>Copying a file from the network, to disk</title>

            <screen>D1:<command>NCD</command> N:

D1:<command>NTRANS</command> 2

D1:<command>NCOPY</command> <parameter>N:HTTPS://WWW.GNU.ORG/licenses/gpl-3.0.txt</parameter>,<parameter>D1:GPL.TXT</parameter>

D1:<command>NTRANS</command> <parameter>0</parameter></screen>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the <acronym>SIO</acronym> error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>NDEL</command></title>

        <subtitle>Delete File on Network</subtitle>

        <synopsis><command>NDEL</command> <parameter>&lt;n:devicespec&gt;</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Remove a file given the desired <filename>N:</filename>
          devicespec.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>&lt;n:devicespec&gt;</parameter></term>

                <listitem>
                  <para>An N: device specification, defined as:</para>

                  <para><filename>N[x]:&lt;proto&gt;://&lt;host&gt;[:port]/[path]</filename></para>

                  <para>where:</para>

                  <itemizedlist>
                    <listitem>
                      <para><filename>[x]</filename> is an optional device
                      number.</para>
                    </listitem>

                    <listitem>
                      <para><filename>&lt;proto&gt;</filename> specifies the
                      protocol.</para>
                    </listitem>

                    <listitem>
                      <para><filename>&lt;host&gt;</filename> the host name or
                      address.</para>
                    </listitem>

                    <listitem>
                      <para><filename>[:port]</filename> is a : followed by
                      port #.</para>
                    </listitem>

                    <listitem>
                      <para><filename>[path]</filename> is an optional
                      path.<important>
                          <para>Any directory specified by
                          <filename>NCD</filename> will automatically be
                          prepended to the beginning of the
                          <filename>N:</filename> devicespec.</para>
                        </important></para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>Deleting a network accessed file with NDEL</title>

            <para><screen>D1:<command>NDEL</command> <parameter>N:TNFS://HOMESERVER/TEST.DOC</parameter></screen></para>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>NDEV</command></title>

        <subtitle>The N: Device Handler</subtitle>

        <synopsis><command>NDEV</command></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Starts the N: device handler, which allows the Atari to
          perform I/O operations on network resources, such as TCP; UDP
          sockets, and perform filesystem operations on resources that have
          paths, such as HTTP, FTP, and TNFS, allowing their use from programs
          that can utilize a full devicespec, such as a DOS command
          processor.</para>
        </simplesect>
      </section>

      <section>
        <title><command>NDIR</command></title>

        <subtitle>Display Network Directory</subtitle>

        <synopsis><command>NDIR </command><parameter>[devicespec]</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Display the directory of a network file system. If no path is
          specified then N:*.* is used.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>[devicespec]</parameter></term>

                <listitem>
                  <para>An N: device specification of the type:</para>

                  <para><filename>N[x]:&lt;proto&gt;://&lt;host&gt;[:port]/[path]</filename></para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>Displaying the Directory of a TNFS Server using
            NDIR</title>

            <para><screen>D1:<command>NDIR</command> <parameter>TNFS://APPS.IRATA.ONLINE/</parameter></screen></para>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>NMKDIR</command></title>

        <subtitle>Make Directory on Network</subtitle>

        <synopsis><command>NMKDIR</command> <parameter>&lt;devicespec&gt;</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Make a directory given the desired devicespec and path.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>&lt;devicespec&gt;</parameter></term>

                <listitem>
                  <para>A N: device specification of the type:</para>

                  <para><filename>N[x]:&lt;proto&gt;://&lt;host&gt;[:port]/[path]</filename></para>

                  <para>Typically ending in the name of a directory to
                  create.</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>Creating a directory called "Games" on a TNFS
            server.</title>

            <para><screen>D1:NMKDIR TNFS://MY-TNFS-SERVER/Games</screen></para>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>NPWD</command></title>

        <subtitle>Show current Nx: Prefix.</subtitle>

        <synopsis><command>NPWD</command></synopsis>

        <simplesect>
          <title>Description</title>

          <para>Show the current working path for N:. This path can be changed
          with the complementary <command>NCD</command> command.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>[N:]</parameter></term>

                <listitem>
                  <para><emphasis>Optional.</emphasis> The N: Device to query.
                  <filename>N1:</filename> is used if not specified.</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>Showing the current prefix on N1: with NPWD</title>

            <para><screen>D1:NCD N:TNFS://TMA-2/

D1:NPWD
TNFS://TMA-2/</screen></para>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <section>
        <title><command>NREN</command></title>

        <subtitle>Rename File on Network</subtitle>

        <synopsis><command>NREN</command> <parameter>&lt;origurl&gt;,&lt;newname&gt;</parameter></synopsis>

        <simplesect>
          <title>Description</title>

          <para>This command tells the FujiNet to reset itself. After waiting
          a few moments, the <trademark class="registered">ATARI</trademark>
          is cold started.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>...</parameter></term>

                <listitem>
                  <para>...</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><parameter>...</parameter></term>

                <listitem>
                  <para>...</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>...</title>

            <para><screen/></para>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <!-- BEGIN Command boiler place -->

      <section>
        <title><command>...</command></title>

        <subtitle>...</subtitle>

        <synopsis><command>...</command></synopsis>

        <simplesect>
          <title>Description</title>

          <para>This command tells the FujiNet to reset itself. After waiting
          a few moments, the <trademark class="registered">ATARI</trademark>
          is cold started.</para>
        </simplesect>

        <simplesect>
          <title>Parameters</title>

          <para><variablelist>
              <varlistentry>
                <term><parameter>...</parameter></term>

                <listitem>
                  <para>...</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><parameter>...</parameter></term>

                <listitem>
                  <para>...</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </simplesect>

        <simplesect>
          <title>Examples</title>

          <example>
            <title>...</title>

            <para><screen/></para>
          </example>
        </simplesect>

        <simplesect>
          <title>Returns</title>

          <para>Error code of 0 on success, 1 on invalid parameters, otherwise
          the SIO error code is returned.</para>
        </simplesect>
      </section>

      <!-- END Command boiler place -->
    </chapter>
  </part>

  <colophon>
    <para>This book was produced using the DocBook 5.1 XML schema, and XSL
    style sheets.</para>

    <para>The source material for this book may be found on GitHub at the
    "fujinet-manuals" repository inside the FujiNet repository group:</para>

    <blockquote>
      <para><link
      xlink:href="https://github.com/FujiNetWIFI/fujinet-manuals/tree/main/fujinet_for_atari_users">https://github.com/FujiNetWIFI/fujinet-manuals/tree/main/fujinet_for_atari_users</link></para>
    </blockquote>

    <para>For the printed format, the xsltproc tool was used to generate the
    intermediate FO format, and Apache FOP was used to process the
    intermediate format into PDF.</para>

    <para>The HTML format is processed using OpenJade, and styled with CSS
    style sheets.</para>
  </colophon>

  <index/>
</book>
